Got it\! Let's move on to **Phase 1, Step 2: Control Flow (Conditionals, Loops)**.

This is where you'll see more similarities with C++ and Java, but with Python's unique syntax for defining blocks and its highly versatile `for` loop.

-----

### Phase 1, Step 2: Control Flow (Conditionals, Loops)

#### 1\. Conditionals (`if`, `elif`, `else`)

**Python:**

  * Uses `if`, `elif` (short for "else if"), and `else` keywords.
  * Conditions do not require parentheses.
  * Code blocks are defined by indentation, followed by a colon `:`.

**C++ / Java Comparison:**

  * Similar to `if`, `else if`, `else`.
  * In C++ and Java, conditions are usually in parentheses `()` and blocks use curly braces `{}`.

**Examples:**

```python
# Simple if-else
age = 20
if age >= 18:
    print("Eligible to vote.")
else:
    print("Not yet eligible to vote.")

# if-elif-else chain
score = 85

if score >= 90:
    grade = "A"
elif score >= 80:
    grade = "B"
elif score >= 70:
    grade = "C"
else:
    grade = "F"
print(f"Your grade is: {grade}")

# Nested if statements (demonstrating indentation)
is_logged_in = True
has_permission = True

if is_logged_in:
    print("User is logged in.")
    if has_permission:
        print("User has permission to access this resource.")
    else:
        print("User does not have permission.")
else:
    print("User is not logged in.")
```

**Key Pythonic Aspects:**

  * **Truthiness:** In Python, many values are inherently "truthy" or "falsy" in a boolean context.

      * **Falsy values:** `None`, `False`, `0` (integer or float), empty sequences (`''`, `[]`, `()`, `{}`), empty sets.
      * **Truthy values:** Everything else.
      * This means you can write `if my_list:` instead of `if not my_list.is_empty():`

    <!-- end list -->

    ```python
    my_list = []
    if my_list: # This evaluates to False because the list is empty
        print("List is not empty.")
    else:
        print("List is empty.")

    name = "John"
    if name: # This evaluates to True because the string is not empty
        print(f"Hello, {name}!")
    ```

#### 2\. Loops (`for`, `while`)

##### `for` Loop (Iteration over collections - powerful\!)

**Python:**

  * The `for` loop in Python is primarily a "for-each" loop. It iterates over *any iterable object* (lists, tuples, strings, dictionaries, ranges, etc.).
  * It does not involve explicit index manipulation unless you specifically request it.

**C++ / Java Comparison:**

  * Most similar to Java's enhanced `for` loop (`for (Type element : collection)`) or C++'s range-based for loop (`for (Type element : collection)`).
  * Less like the traditional C++ `for (int i = 0; i < n; i++)` or Java `for (int i = 0; i < array.length; i++)` (though you can achieve this with `range()`).

**Examples:**

```python
# Iterating over a list
fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
    print(fruit)

# Iterating over a string (strings are iterables of characters)
for char in "Python":
    print(char)

# Iterating using range() (like a traditional C++/Java for loop)
# range(stop): 0 to stop-1
print("\nNumbers from 0 to 4:")
for i in range(5):
    print(i)

# range(start, stop): start to stop-1
print("\nNumbers from 2 to 5:")
for i in range(2, 6):
    print(i)

# range(start, stop, step): start to stop-1, with a step
print("\nEven numbers from 0 to 9:")
for i in range(0, 10, 2):
    print(i)

# Iterating over a dictionary (default is keys)
person = {"name": "Alice", "age": 30, "city": "New York"}
print("\nDictionary keys:")
for key in person:
    print(key)

print("\nDictionary values:")
for value in person.values():
    print(value)

print("\nDictionary items (key-value pairs):")
for key, value in person.items():
    print(f"{key}: {value}")

# Using enumerate() to get index and value (like traditional indexed loop)
colors = ["red", "green", "blue"]
print("\nColors with index:")
for index, color in enumerate(colors):
    print(f"Index {index}: {color}")
```

##### `while` Loop

**Python:**

  * Similar to C++ and Java, it executes a block of code as long as a condition is true.

**C++ / Java Comparison:**

  * Identical in concept to `while` loops in C++ and Java.

**Examples:**

```python
count = 0
while count < 5:
    print(f"Count is: {count}")
    count += 1 # Equivalent to count = count + 1 or count++ (in C++/Java)

# Infinite loop (be careful!)
# while True:
#     print("This will run forever unless stopped (Ctrl+C).")
```

#### 3\. Loop Control Statements (`break`, `continue`)

**Python:**

  * `break`: Terminates the loop entirely.
  * `continue`: Skips the rest of the current iteration and moves to the next iteration of the loop.

**C++ / Java Comparison:**

  * Functionally identical to `break` and `continue` in C++ and Java.

**Examples:**

```python
# Using break
print("\nUsing break:")
for i in range(10):
    if i == 5:
        break # Exit the loop when i is 5
    print(i) # Prints 0, 1, 2, 3, 4

# Using continue
print("\nUsing continue:")
for i in range(10):
    if i % 2 == 0: # If i is even
        continue   # Skip the rest of this iteration (don't print even numbers)
    print(i)       # Prints 1, 3, 5, 7, 9
```

#### 4\. `else` Clause with Loops (Unique to Python\!)

**Python:**

  * A `for` loop or `while` loop can have an optional `else` block.
  * The `else` block executes **only if the loop completes normally (i.e., not terminated by a `break` statement)**.
  * This is often used to execute code if an item was *not* found after searching a list, or if a loop finished its natural course.

**C++ / Java Comparison:**

  * This concept does not exist directly in C++ or Java. You'd typically use a boolean flag to achieve similar logic.

**Examples:**

```python
# Loop with else - completes normally
numbers = [1, 2, 3, 4, 5]
search_target = 6

for num in numbers:
    if num == search_target:
        print(f"Found {search_target}!")
        break # Loop terminated by break, else block will NOT execute
else: # This 'else' belongs to the 'for' loop
    print(f"{search_target} not found in the list (loop completed normally).")

# Loop with else - broken out of
numbers = [1, 2, 3, 4, 5]
search_target = 3

for num in numbers:
    if num == search_target:
        print(f"Found {search_target}!")
        break # Loop terminated by break, else block will NOT execute
else:
    print(f"{search_target} not found in the list (loop completed normally).")
```

#### 5\. No `switch` Statement (Python's Alternatives)

**Python:**

  * Python traditionally does not have a `switch` or `case` statement like C++ or Java.
  * Common alternatives:
      * **`if-elif-else` chain:** Most common and readable for a few conditions.
      * **Dictionary mapping:** For larger sets of distinct actions based on a key.
      * **Python 3.10+ `match` statement:** Introduced in Python 3.10, this is Python's pattern matching feature, which acts as a powerful `switch` alternative.

**C++ / Java Comparison:**

  * C++ has `switch-case`.
  * Java has `switch-case` (and enhanced in recent versions).

**Examples of Python alternatives to `switch`:**

```python
# Using if-elif-else (most common)
day = "Monday"
if day == "Monday":
    print("Start of the week.")
elif day == "Friday":
    print("End of the week!")
else:
    print("Mid-week.")

# Using a dictionary for dispatch (for actions based on string/enum-like values)
def handle_add():
    print("Performing add operation.")
def handle_subtract():
    print("Performing subtract operation.")
def handle_unknown():
    print("Unknown operation.")

operations = {
    "add": handle_add,
    "subtract": handle_subtract,
    # You can add more functions here
}

user_input = "add"
# Get the function from the dictionary, or use handle_unknown if not found
action = operations.get(user_input, handle_unknown)
action() # Call the retrieved function

user_input = "multiply"
action = operations.get(user_input, handle_unknown)
action() # Call the retrieved function

# Using 'match' statement (Python 3.10+) - this is the closest to a switch
python_version = 3.10 # Assume this is your Python version
command = "quit"

match command:
    case "start":
        print("Starting the service.")
    case "stop":
        print("Stopping the service.")
    case "restart":
        print("Restarting the service.")
    case "quit" | "exit": # Multiple patterns for one case
        print("Exiting application.")
    case _: # Default case, similar to 'default' in switch
        print("Unknown command.")

# Example of pattern matching with data (more advanced, like switch on type/structure)
# def process_request(request):
#     match request:
#         case {"type": "login", "user": user, "pass": password}:
#             print(f"Login request for {user}")
#         case {"type": "logout", "user": user}:
#             print(f"Logout request for {user}")
#         case _:
#             print("Unknown request type")
#
# process_request({"type": "login", "user": "admin", "pass": "secret"})
```

-----

#### Your Turn to Practice:

1.  **Number Categorizer (`categorizer.py`):**

      * Ask the user to enter an integer.
      * Use `if-elif-else` to categorize the number:
          * "Positive and Even"
          * "Positive and Odd"
          * "Negative"
          * "Zero"

2.  **Shopping List Loop (`shopping.py`):**

      * Create a Python `list` called `shopping_list` with at least 5 items.
      * Use a `for` loop to iterate through the `shopping_list` and print each item.
      * Use `enumerate()` in another `for` loop to print each item along with its index (e.g., "Item 0: Milk", "Item 1: Eggs").
      * Add a `while` loop that asks the user to input an item to add to the list. The loop should continue until the user types "done".

3.  **Prime Number Checker (Challenge for your C++/Java brain):**

      * Write a Python script that takes an integer `n` as input from the user.
      * Determine if `n` is a prime number (only divisible by 1 and itself).
      * Use a `for` loop (or `while` loop) with a `break` statement if you find a divisor.
      * Use the `else` clause of the loop to print "Is a prime number." if no divisor was found.
      * Handle edge cases: numbers less than or equal to 1 are not prime.

Take your time with these exercises. When you're ready, share your solutions, and we'll review them before moving on to **Data Structures (Built-in Powerhouses)**.