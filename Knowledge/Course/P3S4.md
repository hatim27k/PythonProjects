Alright, let's connect our APIs to persistent storage\! We're moving to **Phase 3, Step 4: Database Integration (SQLAlchemy)**.

Databases are the backbone of almost any serious backend application, providing a way to store and retrieve data reliably.

-----

### Phase 3, Step 4: Database Integration (SQLAlchemy)

#### 1\. Importance of Databases

  * **Persistence:** Data survives application restarts.
  * **Data Management:** Structured storage, efficient retrieval, updates, and deletion.
  * **Concurrency Control:** Handle multiple users accessing/modifying data simultaneously without corruption.
  * **Integrity:** Ensure data consistency and validity (e.g., unique IDs, foreign key constraints).
  * **Scalability:** Modern databases can be scaled to handle massive amounts of data and traffic.

#### 2\. SQL vs. NoSQL (Brief Overview)

  * **SQL (Relational Databases):**
      * **Examples:** PostgreSQL, MySQL, SQLite, Oracle SQL Server.
      * **Structure:** Data stored in tables with predefined schemas (rows and columns). Relationships defined via foreign keys.
      * **Query Language:** SQL (Structured Query Language).
      * **Strengths:** ACID compliance (Atomicity, Consistency, Isolation, Durability), strong data integrity, complex queries (joins).
      * **Use Cases:** Applications requiring complex relationships, strong data consistency (e.g., financial systems, e-commerce orders).
  * **NoSQL (Non-Relational Databases):**
      * **Examples:** MongoDB (Document), Cassandra (Column-Family), Redis (Key-Value), Neo4j (Graph).
      * **Structure:** Flexible schemas, various data models (document, key-value, graph, etc.).
      * **Query Language:** Varies per database, often API-driven.
      * **Strengths:** High scalability (horizontal), flexibility, good for unstructured or semi-structured data, faster for certain access patterns.
      * **Use Cases:** Real-time data, large unstructured datasets, rapid development, distributed systems.

For most traditional backend applications, SQL databases remain a popular and robust choice. We'll focus on them.

#### 3\. Introduction to ORMs (Object-Relational Mappers)

**Concept:**
An ORM (Object-Relational Mapper) is a library that allows you to interact with a relational database using an object-oriented paradigm, rather than writing raw SQL queries.

**Why use an ORM?**

  * **Abstraction:** You work with Python objects (models) and methods instead of SQL tables and commands.
  * **Productivity:** Reduces boilerplate SQL code.
  * **Maintainability:** Easier to refactor and manage schema changes.
  * **Database Agnostic:** Many ORMs (like SQLAlchemy) allow you to switch between different SQL databases with minimal code changes.
  * **Security:** Often helps prevent SQL injection attacks by sanitizing inputs.

**Python ORMs:**

  * **SQLAlchemy:** The most powerful and flexible Python ORM. Can be used as a low-level SQL toolkit (SQLAlchemy Core) or a full ORM.
  * **Django ORM:** Tightly integrated with the Django framework.
  * **PeeWee, SQLModel (built on Pydantic & SQLAlchemy):** Lighter alternatives.

We will focus on **SQLAlchemy**, specifically its ORM component, as it's highly versatile and widely used.

-----

#### 4\. SQLAlchemy ORM

**Installation:**

```bash
# Ensure your virtual environment is activated
pip install sqlalchemy
# For SQLite, no extra driver is needed.
# For PostgreSQL: pip install psycopg2-binary
# For MySQL: pip install pymysql
```

**Connecting to a Database (SQLite Example):**
SQLite is a file-based database, great for local development and testing, as it doesn't require a separate server.

```python
# database.py - Configuration and session setup
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base

# SQLite database URL. 'sqlite:///./test.db' means a file named test.db in current directory.
SQLALCHEMY_DATABASE_URL = "sqlite:///./sql_app.db"
# Or for PostgreSQL: "postgresql://user:password@host:port/dbname"
# Or for MySQL: "mysql+pymysql://user:password@host:port/dbname"

# The engine is the starting point for SQLAlchemy
# connect_args={"check_same_thread": False} is needed for SQLite with FastAPI
# because FastAPI uses multiple threads/processes and SQLite doesn't like that by default.
engine = create_engine(
    SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False}
)

# Each instance of SessionLocal will be a database session.
# The 'autocommit=False' means you need to explicitly call session.commit()
# 'autoflush=False' means that query operations will not automatically flush
# pending changes to the database.
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Base is used to declare models (tables)
Base = declarative_base()
```

**Defining Models (Tables):**

```python
# models.py - Database models/tables
from sqlalchemy import Column, Integer, String, Boolean, ForeignKey
from sqlalchemy.orm import relationship
from .database import Base # Import Base from our database.py

# Define the User model (table)
class User(Base):
    __tablename__ = "users" # Name of the table in the database

    id = Column(Integer, primary_key=True, index=True) # Primary key, auto-incrementing
    email = Column(String, unique=True, index=True)
    hashed_password = Column(String)
    is_active = Column(Boolean, default=True)

    # Relationship to Items: This creates a back-reference
    # 'User.items' will be a list of Item objects associated with this user
    items = relationship("Item", back_populates="owner")

# Define the Item model (table)
class Item(Base):
    __tablename__ = "items"

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, index=True)
    description = Column(String, index=True)
    owner_id = Column(Integer, ForeignKey("users.id")) # Foreign key linking to users.id

    # Relationship to User: This creates a back-reference
    # 'Item.owner' will be the User object that owns this item
    owner = relationship("User", back_populates="items")
```

**Creating Database Tables:**
You typically do this once when your application starts or through database migration tools.

```python
# run_migrations.py (or could be part of main.py's startup logic)
from database import engine, Base
from models import User, Item # Import all your models

def create_db_tables():
    # This creates all tables defined in Base's metadata
    # (i.e., all tables defined in models.py that inherit from Base)
    Base.metadata.create_all(bind=engine)
    print("Database tables created!")

if __name__ == "__main__":
    create_db_tables()
    # After running this, you should see 'sql_app.db' file created
```

**CRUD Operations with SQLAlchemy ORM (Data Access Layer):**

It's good practice to separate your database operations into a data access layer (e.g., `crud.py`).

```python
# crud.py - CRUD operations
from sqlalchemy.orm import Session
from . import models, schemas # We'll define schemas later for FastAPI input/output

# --- User CRUD ---
def get_user(db: Session, user_id: int):
    # .get() is for primary key lookups, .filter() is for other conditions
    return db.query(models.User).filter(models.User.id == user_id).first()

def get_user_by_email(db: Session, email: str):
    return db.query(models.User).filter(models.User.email == email).first()

def get_users(db: Session, skip: int = 0, limit: int = 100):
    return db.query(models.User).offset(skip).limit(limit).all()

def create_user(db: Session, email: str, password: str):
    # In a real app, hash the password before storing!
    fake_hashed_password = password + "notreallyhashed"
    db_user = models.User(email=email, hashed_password=fake_hashed_password)
    db.add(db_user) # Add to the session
    db.commit()    # Commit the transaction to the database
    db.refresh(db_user) # Refresh the instance to get its ID (if auto-generated)
    return db_user

def update_user(db: Session, user_id: int, new_email: str = None, is_active: bool = None):
    db_user = get_user(db, user_id)
    if db_user:
        if new_email:
            db_user.email = new_email
        if is_active is not None:
            db_user.is_active = is_active
        db.commit()
        db.refresh(db_user)
    return db_user

def delete_user(db: Session, user_id: int):
    db_user = get_user(db, user_id)
    if db_user:
        db.delete(db_user)
        db.commit()
        return True
    return False

# --- Item CRUD ---
def get_items(db: Session, skip: int = 0, limit: int = 100):
    return db.query(models.Item).offset(skip).limit(limit).all()

def create_user_item(db: Session, item_title: str, item_description: str, user_id: int):
    db_item = models.Item(title=item_title, description=item_description, owner_id=user_id)
    db.add(db_item)
    db.commit()
    db.refresh(db_item)
    return db_item

def get_item(db: Session, item_id: int):
    return db.query(models.Item).filter(models.Item.id == item_id).first()
```

**Pydantic Schemas for Request/Response (FastAPI Integration):**

We need Pydantic models to define the input and output data structures for our API endpoints.

```python
# schemas.py - Pydantic schemas
from pydantic import BaseModel, EmailStr # EmailStr for email validation

# Base schemas (common fields for creation/update)
class ItemBase(BaseModel):
    title: str
    description: str | None = None

class UserBase(BaseModel):
    email: EmailStr

# Schemas for creating entities
class ItemCreate(ItemBase):
    pass # No extra fields for creation currently

class UserCreate(UserBase):
    password: str # Password is required for creation, but not for base/response

# Schemas for responses (include ID and related fields)
class Item(ItemBase):
    id: int
    owner_id: int # The ID of the owner
    class Config:
        from_attributes = True # Was `orm_mode = True` in older Pydantic/FastAPI, tells Pydantic to read data from ORM objects

class User(UserBase):
    id: int
    is_active: bool
    items: list[Item] = [] # User can have a list of items
    class Config:
        from_attributes = True # Allows Pydantic to map ORM objects
```

#### 5\. Integrating with FastAPI

Now, let's combine FastAPI with SQLAlchemy. A common pattern is to use FastAPI's **Dependency Injection** system to provide a database session to each endpoint.

```python
# main.py - FastAPI application with database integration
from fastapi import FastAPI, Depends, HTTPException, status
from sqlalchemy.orm import Session
import uvicorn

from . import crud, models, schemas
from .database import SessionLocal, engine, Base # Import database setup

# Create database tables when the application starts
# In production, you'd use Alembic for migrations instead
Base.metadata.create_all(bind=engine)

app = FastAPI(title="FastAPI + SQLAlchemy Demo")

# Dependency to get a database session
def get_db():
    db = SessionLocal() # Create a session
    try:
        yield db # Yield the session to the endpoint
    finally:
        db.close() # Ensure the session is closed after the request

# --- User Endpoints ---
@app.post("/users/", response_model=schemas.User, status_code=status.HTTP_201_CREATED)
async def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):
    db_user = crud.get_user_by_email(db, email=user.email)
    if db_user:
        raise HTTPException(status_code=400, detail="Email already registered")
    return crud.create_user(db=db, email=user.email, password=user.password)

@app.get("/users/", response_model=list[schemas.User])
async def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    users = crud.get_users(db, skip=skip, limit=limit)
    return users

@app.get("/users/{user_id}", response_model=schemas.User)
async def read_user(user_id: int, db: Session = Depends(get_db)):
    db_user = crud.get_user(db, user_id=user_id)
    if db_user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return db_user

# --- Item Endpoints ---
@app.post("/users/{user_id}/items/", response_model=schemas.Item, status_code=status.HTTP_201_CREATED)
async def create_item_for_user(
    user_id: int, item: schemas.ItemCreate, db: Session = Depends(get_db)
):
    db_user = crud.get_user(db, user_id=user_id)
    if db_user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return crud.create_user_item(db=db, item_title=item.title, item_description=item.description, user_id=user_id)

@app.get("/items/", response_model=list[schemas.Item])
async def read_items(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    items = crud.get_items(db, skip=skip, limit=limit)
    return items

@app.get("/items/{item_id}", response_model=schemas.Item)
async def read_item(item_id: int, db: Session = Depends(get_db)):
    db_item = crud.get_item(db, item_id=item_id)
    if db_item is None:
        raise HTTPException(status_code=404, detail="Item not found")
    return db_item

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000, reload=True)
```

**Project Structure:**

```
my_fastapi_app/
├── main.py
├── database.py
├── models.py
├── schemas.py
└── crud.py
```

**Steps to Run this Integrated App:**

1.  **Create the directory structure:** `my_fastapi_app/`.
2.  **Create `database.py`, `models.py`, `schemas.py`, `crud.py`, `main.py`** in that order, pasting the code above into each.
3.  **Run migrations:** Navigate to the `my_fastapi_app/` directory in your terminal and run `python -c "from database import Base, engine; Base.metadata.create_all(bind=engine)"` or create a small `init_db.py` file like the `run_migrations.py` example shown earlier and run `python init_db.py`. This will create `sql_app.db`.
4.  **Start the FastAPI app:** From the `my_fastapi_app/` directory, run `uvicorn main:app --reload`.
5.  **Test using Postman/curl and `/docs`:**
      * **Create a user:** `POST http://127.0.0.1:8000/users/` with JSON body: `{"email": "test@example.com", "password": "password123"}`
      * **Get users:** `GET http://127.0.0.1:8000/users/`
      * **Create an item for a user:** `POST http://127.0.0.1:8000/users/1/items/` with JSON body: `{"title": "My First Item", "description": "This is a cool item"}` (assuming user ID 1 was created).
      * **Get all items:** `GET http://127.0.0.1:8000/items/`
      * **Get a specific item:** `GET http://127.0.0.1:8000/items/1`

-----

#### Your Turn to Practice:

1.  **Refactor Task Manager with SQLAlchemy (`sql_task_manager/`):**
      * Building on your FastAPI task manager.
      * Create a new directory (e.g., `sql_task_manager/`) and set up `database.py`, `models.py`, `schemas.py`, `crud.py`, and `main.py` for a task management application.
      * **Models:** Define a `Task` model in `models.py` with fields like `id`, `title`, `description`, `status` (e.g., `String` for "pending", "completed"), `created_at` (use `Column(DateTime, default=func.now())` from `sqlalchemy`), and potentially `due_date`.
      * **Schemas:** Create Pydantic schemas for `TaskCreate`, `TaskUpdate`, and `TaskResponse`.
      * **CRUD:** Implement SQLAlchemy ORM functions in `crud.py` for:
          * `create_task`
          * `get_task`
          * `get_tasks`
          * `update_task`
          * `delete_task`
      * **FastAPI Endpoints:** Integrate these CRUD functions into your `main.py` FastAPI app, using `Depends(get_db)` to manage sessions.
      * Run and test all your API endpoints with persistence\!

This exercise will give you a solid understanding of how to build a production-ready API with a database backend using FastAPI and SQLAlchemy, a very common and powerful stack.

When you're ready, we'll move on to **Phase 3, Step 5: Authentication and Authorization**. This is crucial for securing your APIs\!