Alright, let's move on to **Phase 1, Step 6: Error Handling**.

Error handling in Python uses a `try-except` mechanism, which is very similar in concept to `try-catch` in Java and C++. Python also includes `else` and `finally` clauses that provide more nuanced control over execution flow during error handling.

-----

### Phase 1, Step 6: Error Handling

#### 1\. Basic `try-except` Block

**Python:**

  * Code that might raise an exception is placed inside the `try` block.
  * If an exception occurs in the `try` block, Python immediately jumps to the corresponding `except` block.
  * If no exception occurs, the `except` block is skipped.

**C++ / Java Comparison:**

  * Directly analogous to `try { ... } catch (ExceptionType e) { ... }`.

**Examples:**

```python
# Handling a specific exception
try:
    num1 = int(input("Enter a numerator: "))
    num2 = int(input("Enter a denominator: "))
    result = num1 / num2
    print(f"Result of division: {result}")
except ZeroDivisionError: # Catching a specific exception type
    print("Error: Cannot divide by zero!")
except ValueError: # Catching another specific exception type
    print("Error: Invalid input. Please enter integers only.")

print("Program continues after error handling.")

# Handling multiple specific exceptions in one except block (Python 3.3+)
try:
    value = int("hello") # This would raise a ValueError
except (ValueError, TypeError) as e: # Catching multiple types
    print(f"An input/type error occurred: {e}")

# Catching all exceptions (generally discouraged unless re-raising or logging)
try:
    data = {"key": "value"}
    print(data["non_existent_key"]) # This would raise a KeyError
except Exception as e: # Catching the base Exception class
    print(f"An unexpected error occurred: {type(e).__name__}: {e}")
```

-----

#### 2\. The `else` Clause with `try-except`

**Python:**

  * The `else` block (associated with `try`) executes *only if no exception occurs* in the `try` block.
  * It's a good place for code that should run if the `try` block succeeds but doesn't need to be part of the `try` block itself (keeping the `try` block lean).

**C++ / Java Comparison:**

  * No direct equivalent. In Java/C++, you'd just put this code immediately after the `try-catch` block, but the `else` explicitly signals its dependency on the `try` block's success.

**Examples:**

```python
def safe_divide():
    try:
        num1 = int(input("Enter first number: "))
        num2 = int(input("Enter second number: "))
        result = num1 / num2
    except ValueError:
        print("Invalid input. Please enter numbers.")
    except ZeroDivisionError:
        print("Cannot divide by zero.")
    else: # This block runs ONLY if no exception occurred in the 'try' block
        print(f"Division successful! Result: {result}")
        # Any post-success processing can go here
    finally: # This block runs always, regardless of exception
        print("Division attempt finished.")

print("--- Successful division attempt ---")
# safe_divide() # Test with valid numbers like 10, 2

print("\n--- Division by zero attempt ---")
# safe_divide() # Test with 10, 0

print("\n--- Invalid input attempt ---")
# safe_divide() # Test with "abc", 2
```

-----

#### 3\. The `finally` Clause

**Python:**

  * The `finally` block *always* executes, regardless of whether an exception occurred in the `try` block or not.
  * It's typically used for cleanup operations that must happen (e.g., closing files, database connections, releasing locks).

**C++ / Java Comparison:**

  * Directly analogous to `finally { ... }` in Java.
  * In C++, you'd use RAII (Resource Acquisition Is Initialization) or specific cleanup code after the `try-catch` block.

**Examples:**

```python
def process_file(filename):
    file = None # Initialize file handle
    try:
        file = open(filename, "r")
        content = file.read()
        print("File content read successfully.")
        # Simulate an error after reading
        # raise ValueError("Simulating an error after read")
        return content
    except FileNotFoundError:
        print(f"Error: File '{filename}' not found.")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
    finally:
        # This block always executes, even if an error occurred or file was not found
        if file: # Check if file object was successfully created
            file.close()
            print(f"File '{filename}' closed.")
        else:
            print("No file was opened (or already closed).")

# Test cases:
# print("\n--- Valid file access ---")
# with open("my_test_file.txt", "w") as f:
#     f.write("Hello from test file!")
# process_file("my_test_file.txt")

# print("\n--- File not found ---")
# process_file("non_existent_file.txt")

# print("\n--- Simulate error after opening ---")
# with open("another_test_file.txt", "w") as f:
#     f.write("Data that won't be fully processed.")
# process_file("another_test_file.txt")
```

**Note:** For file handling and other resources, Python's `with` statement (context managers) is often preferred over `try-finally` for simpler cleanup, as it handles closing automatically. We will cover this in a later section.

-----

#### 4\. Raising Exceptions (`raise`)

**Python:**

  * You can explicitly raise an exception using the `raise` keyword.
  * This is useful for signaling an error condition in your code that callers should handle.
  * You can raise built-in exceptions or custom exceptions.

**C++ / Java Comparison:**

  * Directly analogous to `throw` in C++ or `throw new Exception()` in Java.

**Examples:**

```python
def check_age(age):
    if not isinstance(age, (int, float)):
        raise TypeError("Age must be a number.")
    if age < 0:
        raise ValueError("Age cannot be negative.")
    if age < 18:
        raise Exception("User is too young.") # Raising a generic Exception (less specific)
    print(f"Age {age} is valid.")

try:
    check_age(25)
    check_age(-5) # This will raise ValueError
except ValueError as e:
    print(f"Caught an age error: {e}")

try:
    check_age("twenty") # This will raise TypeError
except TypeError as e:
    print(f"Caught a type error: {e}")

try:
    check_age(15) # This will raise Exception
except Exception as e: # Catching the generic Exception
    print(f"Caught a generic error: {e}")
```

-----

#### 5\. Custom Exceptions

**Python:**

  * You can define your own custom exception classes by inheriting from `Exception` (or a more specific built-in exception).
  * This improves code clarity and allows for more granular error handling by callers.

**C++ / Java Comparison:**

  * Similar to creating custom exception classes by extending `std::exception` (C++) or `Exception` / `RuntimeException` (Java).

**Examples:**

```python
# Define a custom exception
class InsufficientFundsError(Exception):
    """Exception raised for errors in the amount of available funds."""
    def __init__(self, message="Insufficient funds in the account.", current_balance=0, attempted_withdrawal=0):
        self.message = message
        self.current_balance = current_balance
        self.attempted_withdrawal = attempted_withdrawal
        super().__init__(self.message) # Call the base class constructor

class BankAccount:
    def __init__(self, initial_balance):
        if initial_balance < 0:
            raise ValueError("Initial balance cannot be negative.")
        self.balance = initial_balance

    def withdraw(self, amount):
        if amount <= 0:
            raise ValueError("Withdrawal amount must be positive.")
        if self.balance < amount:
            raise InsufficientFundsError(
                f"Attempted to withdraw ${amount} but only ${self.balance} available.",
                current_balance=self.balance,
                attempted_withdrawal=amount
            )
        self.balance -= amount
        print(f"Withdrew ${amount}. New balance: ${self.balance}")

# Test custom exception
account = BankAccount(100)
try:
    account.withdraw(50)
    account.withdraw(80) # This will raise InsufficientFundsError
except InsufficientFundsError as e:
    print(f"Transaction failed: {e.message}")
    print(f"Details: Current Balance=${e.current_balance}, Attempted Withdrawal=${e.attempted_withdrawal}")
except ValueError as e:
    print(f"Withdrawal error: {e}")
```

-----

#### Your Turn to Practice:

1.  **File Reader with Error Handling (`file_reader.py`):**

      * Write a function `read_and_process_file(filepath)`.
      * Use a `try-except` block to:
          * Attempt to open and read the content of the `filepath`.
          * Catch `FileNotFoundError` if the file doesn't exist and print an appropriate message.
          * Catch any `IOError` (a broader category for input/output errors) for other file-related issues.
          * Use an `else` block to print "File read successfully, content length: [length]" if no error occurred.
          * Use a `finally` block to print "Attempted file operation complete." regardless of success or failure.
      * Test with:
          * A valid file (create a dummy `test.txt` with some content).
          * A non-existent file.
          * (Optional, advanced) Try to simulate an `IOError` (e.g., by trying to open a directory as a file, or attempting to write to a read-only file if your OS allows this simulation).

2.  **Password Validator (`password_validator.py`):**

      * Define a custom exception class `InvalidPasswordError` that inherits from `Exception`. It should take a `message` argument.
      * Write a function `validate_password(password)`:
          * Raise `InvalidPasswordError` if the password is:
              * Less than 8 characters long.
              * Does not contain at least one uppercase letter.
              * Does not contain at least one digit.
          * If the password is valid, print "Password is valid."
      * Use `try-except` blocks to call `validate_password` with various inputs (valid, too short, no uppercase, no digit) and catch `InvalidPasswordError` to print a user-friendly message. (Hint: you can check for uppercase/digits using `any(char.isupper() for char in password)` and `any(char.isdigit() for char in password)`).

These exercises will help you master Python's robust error handling mechanisms. Let me know when you're ready, and we'll proceed to **Phase 2: Pythonic Deep Dive & Performance**, starting with **Generators & Iterators**.