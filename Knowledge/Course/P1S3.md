Got it\! Let's dive into **Phase 1, Step 3: Data Structures (Built-in Powerhouses)**.

This is where Python really shines with its highly optimized and easy-to-use built-in collections. You'll find them incredibly versatile compared to managing arrays, ArrayLists, HashMaps, etc., explicitly in C++ or Java.

-----

### Phase 1, Step 3: Data Structures (Built-in Powerhouses)

Python provides four core built-in collection types that you will use constantly: `list`, `tuple`, `dict`, and `set`. Understanding their characteristics (mutability, order, uniqueness, indexing) is key.

-----

#### 1\. Lists (`list`)

**Concept:**

  * An ordered, mutable (changeable) sequence of items.
  * Can contain items of different data types (heterogeneous).
  * Enclosed in square brackets `[]`.
  * Dynamic resizing (similar to `ArrayList` in Java or `std::vector` in C++).

**C++ / Java Comparison:**

  * Most analogous to `java.util.ArrayList` or `std::vector<T>` in C++. Key difference: Python lists are inherently heterogeneous; you don't declare a type for the list elements.

**Examples:**

```python
# Creating lists
my_list = [1, 2, 3, 4, 5]
mixed_list = [1, "hello", 3.14, True]
empty_list = []

print(f"my_list: {my_list}")
print(f"mixed_list: {mixed_list}")

# Accessing elements (0-indexed, like C++/Java arrays)
print(f"First element: {my_list[0]}")
print(f"Last element: {my_list[4]}") # or my_list[-1] (negative indexing from end)
print(f"Second to last: {my_list[-2]}")

# Slicing (powerful for sub-lists) - [start:end:step]
# Similar to substring in Java or substr in C++, but for any sequence
print(f"Elements from index 1 to 3 (exclusive): {my_list[1:4]}") # Output: [2, 3, 4]
print(f"All elements from index 2 to end: {my_list[2:]}") # Output: [3, 4, 5]
print(f"All elements up to index 3 (exclusive): {my_list[:4]}") # Output: [1, 2, 3, 4]
print(f"Copy of the list: {my_list[:]}") # Output: [1, 2, 3, 4, 5]
print(f"Every second element: {my_list[::2]}") # Output: [1, 3, 5]
print(f"Reversed list: {my_list[::-1]}") # Output: [5, 4, 3, 2, 1]

# Modifying elements (mutable)
my_list[0] = 10
print(f"Modified first element: {my_list}") # Output: [10, 2, 3, 4, 5]

# Adding elements
my_list.append(6)       # Add to the end
print(f"After append: {my_list}") # Output: [10, 2, 3, 4, 5, 6]
my_list.insert(1, 99)   # Insert at a specific index
print(f"After insert: {my_list}") # Output: [10, 99, 2, 3, 4, 5, 6]
my_list.extend([7, 8])  # Add elements from another iterable
print(f"After extend: {my_list}") # Output: [10, 99, 2, 3, 4, 5, 6, 7, 8]

# Removing elements
my_list.remove(99)      # Remove first occurrence of value
print(f"After remove 99: {my_list}") # Output: [10, 2, 3, 4, 5, 6, 7, 8]
popped_item = my_list.pop() # Remove and return last element
print(f"Popped item: {popped_item}, List after pop: {my_list}") # Output: Popped item: 8, List after pop: [10, 2, 3, 4, 5, 6, 7]
del my_list[0]          # Delete element at index
print(f"After del index 0: {my_list}") # Output: [2, 3, 4, 5, 6, 7]
# my_list.clear() # Removes all items

# Other useful list methods
print(f"Length of list: {len(my_list)}")
print(f"Is 3 in list? {3 in my_list}")
print(f"Count of 2s: {my_list.count(2)}")
my_list.sort() # Sorts in-place (ascending by default)
print(f"Sorted list: {my_list}")
new_sorted_list = sorted([5, 1, 8, 2]) # Returns a new sorted list
print(f"New sorted list: {new_sorted_list}")
my_list.reverse() # Reverses in-place
print(f"Reversed sorted list: {my_list}")
```

#### 2\. Tuples (`tuple`)

**Concept:**

  * An ordered, **immutable** sequence of items.
  * Once created, a tuple's contents cannot be changed (items cannot be added, removed, or modified).
  * Enclosed in parentheses `()`.
  * Often used for heterogeneous collections of elements that belong together, or as dictionary keys (since they are immutable).

**C++ / Java Comparison:**

  * There's no direct equivalent. Think of them as immutable, fixed-size `ArrayLists` or simplified `struct`/`record` types, but capable of holding different types.

**Examples:**

```python
# Creating tuples
my_tuple = (1, 2, "three", True)
single_item_tuple = (5,) # Comma is crucial for single-item tuples!
empty_tuple = ()

print(f"my_tuple: {my_tuple}")
print(f"single_item_tuple: {single_item_tuple}")

# Accessing elements (like lists, 0-indexed)
print(f"First element: {my_tuple[0]}")
print(f"Last element: {my_tuple[-1]}")

# Slicing (returns a new tuple)
print(f"Slice: {my_tuple[1:3]}") # Output: (2, 'three')

# Tuples are immutable - this will raise an error!
# my_tuple[0] = 10 # TypeError: 'tuple' object does not support item assignment

# Useful for unpacking (assigning tuple elements to individual variables)
coordinates = (10.0, 20.0)
x, y = coordinates
print(f"X: {x}, Y: {y}")

# Can be used as dictionary keys because they are immutable
# dict_key_tuple = {(1, 2): "Value for 1,2"}
```

-----

#### 3\. Dictionaries (`dict`)

**Concept:**

  * An unordered (pre-Python 3.7) or insertion-ordered (Python 3.7+), mutable collection of **key-value pairs**.
  * Keys must be unique and immutable (e.g., numbers, strings, tuples). Values can be any data type.
  * Enclosed in curly braces `{}` with `key: value` pairs.

**C++ / Java Comparison:**

  * Most analogous to `java.util.HashMap` or `std::unordered_map` (or `std::map` if you care about sorted keys in C++).

**Examples:**

```python
# Creating dictionaries
person = {"name": "Alice", "age": 30, "city": "New York"}
empty_dict = {}

# Dictionary from key-value pairs using dict() constructor
student = dict(name="Bob", id=123, major="CS")

print(f"Person: {person}")
print(f"Student: {student}")

# Accessing values (using keys)
print(f"Alice's age: {person['age']}")

# Getting a value safely (prevents KeyError if key not found)
print(f"Alice's occupation (get method): {person.get('occupation', 'Not specified')}")

# Adding/modifying elements
person["occupation"] = "Engineer" # Add new key-value pair
person["age"] = 31               # Modify existing value
print(f"After modification: {person}")

# Removing elements
del person["city"] # Remove by key
print(f"After deleting city: {person}")

popped_value = person.pop("age") # Remove by key and return value
print(f"Popped age: {popped_value}, Dict after pop: {person}")

# Other useful dictionary methods
print(f"All keys: {person.keys()}")     # Returns a dict_keys object (iterable)
print(f"All values: {person.values()}") # Returns a dict_values object (iterable)
print(f"All items: {person.items()}")   # Returns a dict_items object (iterable of (key, value) tuples)

# Iterating over dictionaries (already covered in Control Flow, but good to reiterate)
print("\nIterating over person dictionary:")
for key, value in person.items():
    print(f"{key}: {value}")

# Check if key exists
print(f"Is 'name' a key in person? {'name' in person}")
print(f"Is 'city' a key in person? {'city' in person}")
```

-----

#### 4\. Sets (`set`)

**Concept:**

  * An unordered collection of **unique** elements.
  * Mutable (you can add or remove elements, but elements themselves must be immutable).
  * Enclosed in curly braces `{}` (but watch out: `{}` without key-value pairs creates an empty dictionary, not an empty set). An empty set is created with `set()`.
  * Supports mathematical set operations (union, intersection, difference, symmetric difference).

**C++ / Java Comparison:**

  * Most analogous to `java.util.HashSet` or `std::unordered_set` in C++.

**Examples:**

```python
# Creating sets
my_set = {1, 2, 3, 2, 1} # Duplicate values are automatically ignored
print(f"my_set (duplicates removed): {my_set}") # Output: {1, 2, 3} (order not guaranteed)

empty_set = set() # IMPORTANT: Use set() for an empty set
print(f"empty_set: {empty_set}")

# Set from a list (useful for removing duplicates from a list)
numbers_with_duplicates = [1, 2, 2, 3, 4, 4, 5]
unique_numbers = set(numbers_with_duplicates)
print(f"Unique numbers from list: {unique_numbers}") # Output: {1, 2, 3, 4, 5}

# Adding elements
unique_numbers.add(6)
print(f"After adding 6: {unique_numbers}")
unique_numbers.add(3) # Adding an existing element has no effect
print(f"After adding 3 again: {unique_numbers}")

# Removing elements
unique_numbers.remove(2) # Raises KeyError if element not found
print(f"After removing 2: {unique_numbers}")
unique_numbers.discard(7) # Does nothing if element not found (safer)
print(f"After discarding 7: {unique_numbers}")
popped_item = unique_numbers.pop() # Removes and returns an arbitrary element
print(f"Popped item from set: {popped_item}, Set after pop: {unique_numbers}")

# Set operations (like mathematics)
set_a = {1, 2, 3, 4}
set_b = {3, 4, 5, 6}

print(f"Union (A or B): {set_a.union(set_b)}") # Output: {1, 2, 3, 4, 5, 6}
print(f"Intersection (A and B): {set_a.intersection(set_b)}") # Output: {3, 4}
print(f"Difference (A minus B): {set_a.difference(set_b)}") # Output: {1, 2}
print(f"Symmetric Difference (elements in A or B, but not both): {set_a.symmetric_difference(set_b)}") # Output: {1, 2, 5, 6}

print(f"Is set_a a subset of {set_a | set_b}? {set_a.issubset(set_a | set_b)}") # Using operator for union
```

-----

#### 5\. Immutability Revisited (Crucial Concept for Keys/Hashing)

  * **Immutable Types:** `int`, `float`, `bool`, `str`, `tuple`.
      * These can be used as keys in dictionaries and elements in sets because their hash value does not change after creation.
  * **Mutable Types:** `list`, `dict`, `set`.
      * These **cannot** be used as keys in dictionaries or elements in sets because their contents can change, which would affect their hash value, breaking the integrity of the hash table.

-----

#### Your Turn to Practice:

1.  **List Manipulator (`list_ops.py`):**

      * Create a list of your 5 favorite movies.
      * Print the list.
      * Add two more movies to the end.
      * Insert a movie at the second position.
      * Remove one movie by its value.
      * Remove the last movie using `pop()` and print the removed movie.
      * Sort the list alphabetically and print it.
      * Print the first three movies using slicing.
      * Print the list in reverse order using slicing.

2.  **Student Profile Dictionary (`student_dict.py`):**

      * Create a dictionary for a student with keys: `name`, `id`, `courses` (which should be a list of strings), and `gpa`.
      * Assign initial values.
      * Print the student's name and GPA.
      * Add a new course to their `courses` list.
      * Update their GPA.
      * Try to retrieve a non-existent key using `get()` with a default value, and print the result.
      * Iterate through the dictionary and print all key-value pairs.

3.  **Unique Words (`unique_words.py`):**

      * Take a sentence as input from the user (e.g., "Python is fun and Python is powerful").
      * Convert the sentence to lowercase.
      * Split the sentence into individual words (you can use `sentence.split()`).
      * Use a `set` to find and print all the unique words in the sentence.

Take your time with these exercises. When you're ready, share your solutions, and we'll review them before moving on to **Functions & Scope**.