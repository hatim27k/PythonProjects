Alright, let's advance to **Phase 3, Step 3: FastAPI - Modern Async APIs**.

While Flask is excellent for understanding core web framework concepts, **FastAPI** has rapidly become the go-to framework for building high-performance, modern, and robust APIs in Python, especially in cloud-native environments. It leverages Python's type hints and `asyncio` to offer incredible benefits.

-----

### Phase 3, Step 3: FastAPI - Modern Async APIs

#### 1\. Why FastAPI?

FastAPI is a relatively new (released in 2018) but incredibly popular web framework that offers several compelling advantages for backend development:

  * **High Performance:** Built on Starlette (for web parts) and Pydantic (for data validation/serialization), both of which are extremely fast. It leverages `asyncio` for asynchronous operations, making it highly efficient for I/O-bound tasks.
  * **Intuitive & Easy to Use:** Designed for developer productivity.
  * **Automatic Data Validation & Serialization:** Uses Python type hints and Pydantic. You define your data models using standard Python types, and FastAPI handles validation of incoming request data and serialization of outgoing response data automatically. This significantly reduces boilerplate code and common data-related bugs.
  * **Automatic Interactive API Documentation:** Generates OpenAPI (formerly Swagger) and ReDoc documentation automatically based on your code and type hints. This documentation is interactive and allows clients to explore and test your API directly from a browser.
  * **Asynchronous Support (`async`/`await`):** Built from the ground up to support Python's `asyncio` framework, making it ideal for high-concurrency I/O operations (e.g., database queries, external API calls, waiting for messages).
  * **Dependency Injection:** A powerful system for managing dependencies (e.g., database connections, authentication details) in your endpoints.
  * **Extensible:** Easy to add custom middleware, error handlers, and security mechanisms.

**C++ / Java Comparison:**

  * FastAPI's automatic data validation and documentation based on type hints are somewhat comparable to frameworks that use annotations or schema definitions (like JAX-RS with OpenAPI annotations in Java, or certain C++ REST frameworks that use IDL files), but integrated very elegantly within Python itself.
  * Its async nature is akin to Netty or Spring WebFlux in Java, or asynchronous frameworks in C++ that use event loops (like Boost.Asio).

-----

#### 2\. Installation

You'll need `fastapi` and an ASGI server to run it (like `uvicorn`).

```bash
# Ensure your virtual environment is activated
pip install fastapi uvicorn[standard]
```

  * `uvicorn[standard]` installs `uvicorn` along with standard dependencies like `python-dotenv` for environment variables, `websockets` etc.

-----

#### 3\. Basic "Hello, World\!" API (`main.py`)

```python
from fastapi import FastAPI

# Create a FastAPI application instance
app = FastAPI()

# A simple GET route for the root URL
@app.get("/")
async def read_root(): # Use 'async def' for asynchronous endpoints
    return {"message": "Hello, FastAPI!"}

# A simple GET route for another endpoint
@app.get("/data")
async def get_my_data():
    return {
        "framework": "FastAPI",
        "language": "Python",
        "version": "1.0"
    }

# To run the FastAPI application:
# 1. Save the code as main.py (or app.py).
# 2. Open your terminal in the same directory.
# 3. Ensure your virtual environment is activated.
# 4. Run: uvicorn main:app --reload
#    - `main`: refers to the Python file `main.py`
#    - `app`: refers to the `app` object inside `main.py`
#    - `--reload`: enables auto-reloading on code changes (for development)

# You should see output similar to:
# INFO:     Will watch for changes in '.'.
# INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
# INFO:     Started reloader process [....]
# INFO:     Started server process [....]
# INFO:     Waiting for application startup.
# INFO:     Application startup complete.

# Open your browser or use curl/Postman to test:
# http://127.0.0.1:8000/
# http://127.0.0.1:8000/data

# IMPORTANT: Check the automatic documentation!
# http://127.0.0.1:8000/docs (Swagger UI)
# http://127.0.0.1:8000/redoc (ReDoc)
```

-----

#### 4\. Path Parameters

Similar to Flask, but with strong typing\!

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/items/{item_id}")
async def read_item(item_id: int): # Type hint 'int' for automatic validation
    return {"item_id": item_id, "message": f"This is item number {item_id}"}

# Try accessing:
# http://127.0.0.1:8000/items/5
# http://127.0.0.1:8000/items/abc # This will automatically return a 422 Unprocessable Entity error due to type validation!
```

-----

#### 5\. Query Parameters

Also uses type hints for automatic validation and default values.

```python
from fastapi import FastAPI, Query

app = FastAPI()

# Optional query parameter 'q' with a default value of None
@app.get("/users/")
async def read_users(q: str | None = None): # Python 3.10+ uses 'str | None' for Optional[str]
    if q:
        return {"message": f"Searching for users with query: {q}"}
    return {"message": "No query provided for users."}

# Query parameter with a default value and minimum length constraint
@app.get("/products/")
async def read_products(name: str = Query(..., min_length=3)): # '...' means required
    return {"message": f"Searching for product name: {name}"}

# Try accessing:
# http://127.0.0.1:8000/users/
# http://127.0.0.1:8000/users/?q=Alice
# http://127.0.0.1:8000/products/?name=apple
# http://127.0.0.1:8000/products/?name=ap # Will get a 422 error
# http://127.0.0.1:8000/docs for the auto-generated documentation on these endpoints.
```

-----

#### 6\. Request Body with Pydantic

This is where FastAPI truly shines. You define data structures using Pydantic models, and FastAPI automatically:

  * Parses JSON request bodies.
  * Validates data types and constraints.
  * Provides clear error messages if validation fails.
  * Serializes Python objects back to JSON for responses.

<!-- end list -->

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel # Import BaseModel for creating data models

app = FastAPI()

# 1. Define a Pydantic model for the incoming request body (data validation)
class Item(BaseModel):
    name: str
    description: str | None = None # Optional field
    price: float
    tax: float | None = None # Optional field

# 2. Use the Pydantic model in your endpoint function
@app.post("/items/")
async def create_item(item: Item): # FastAPI automatically parses JSON into an Item object
    # The 'item' object is now a validated Pydantic model instance
    item_dict = item.model_dump() # Convert Pydantic model to a Python dict
    if item.tax:
        price_with_tax = item.price + item.tax
        item_dict.update({"price_with_tax": price_with_tax})
    return item_dict

# 3. Another model for updating an item (could be partial)
class UpdateItem(BaseModel):
    name: str | None = None
    description: str | None = None
    price: float | None = None
    tax: float | None = None

@app.patch("/items/{item_id}") # PATCH for partial updates
async def update_item_partial(item_id: int, item: UpdateItem):
    # In a real app, you'd fetch the item from DB, update it, and save it.
    # For now, just return what we received.
    return {"item_id": item_id, "updated_data": item.model_dump(exclude_unset=True)}

# Test with Postman/curl:
# POST http://127.0.0.1:8000/items/
# Body (raw JSON):
# {
#   "name": "Laptop",
#   "description": "Powerful gaming laptop",
#   "price": 1200.50,
#   "tax": 96.04
# }
# Try sending without "name" or with "price": "abc" - see the automatic 422 error!

# PATCH http://127.0.0.1:8000/items/123
# Body (raw JSON):
# {
#   "price": 1250.00
# }
```

-----

#### 7\. HTTP Methods in FastAPI

FastAPI provides decorators for each common HTTP method:

  * `@app.get()`
  * `@app.post()`
  * `@app.put()`
  * `@app.delete()`
  * `@app.patch()`
  * `@app.options()`
  * `@app.head()`
  * `@app.trace()` (less common)

You can also use `@app.api_route(path, methods=["GET", "POST"])` for multiple methods on one path, though separate decorators are often clearer.

-----

#### 8\. Automatic Documentation (Swagger UI / ReDoc)

As mentioned, this is a huge benefit. Just navigate to:

  * `http://127.0.0.1:8000/docs` (Swagger UI)
  * `http://127.0.0.1:8000/redoc` (ReDoc)

This documentation is live, interactive, and automatically updates as you change your Pydantic models and endpoint definitions. It's invaluable for frontend developers or other API consumers.

-----

#### 9\. Asynchronous Operations (`async def` and `await`)

  * FastAPI endpoints are defined with `async def` by default. This signals to Uvicorn (the ASGI server) that this function is a coroutine and can be paused/resumed by the event loop.
  * When your endpoint needs to perform I/O-bound operations (e.g., fetching data from a database, calling an external API, reading from disk), you should use `await` with an `async` compatible library.
  * **Important:** If you have CPU-bound operations, `async def` will *not* make them run in parallel. It will still block the event loop. For CPU-bound tasks, you might need to run them in a separate process or use FastAPI's `run_in_threadpool` (which is automatically done for regular `def` functions in FastAPI if you don't `await` anything).

<!-- end list -->

```python
import asyncio
import httpx # Async HTTP client library, similar to 'requests' but async

app = FastAPI()

@app.get("/async-data")
async def get_async_data():
    print("Starting async operation...")
    await asyncio.sleep(1) # Simulate an async I/O operation (e.g., database query)
    print("Async operation completed.")
    return {"message": "Data fetched asynchronously!"}

@app.get("/fetch-external-api")
async def fetch_external():
    async with httpx.AsyncClient() as client:
        response = await client.get("https://jsonplaceholder.typicode.com/todos/1")
        todo = response.json()
        return {"todo": todo}

# Test these endpoints. You'll notice they don't block each other if you
# make multiple requests quickly, unlike synchronous Flask endpoints that
# would block while one is waiting for a sleep/network call.
```

-----

#### 10\. Error Handling (`HTTPException`)

FastAPI provides `HTTPException` for returning standard HTTP error responses.

```python
from fastapi import FastAPI, HTTPException, status

app = FastAPI()

items = {"foo": "The Foo Wrestlers", "bar": "The Bar Fighters"}

@app.get("/items/{item_id}")
async def read_item_with_error(item_id: str):
    if item_id not in items:
        # Raise HTTPException with a status code and detail message
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Item not found")
    return {"item": items[item_id]}

# Test:
# http://127.0.0.1:8000/items/foo
# http://127.0.0.1:8000/items/baz # This will return a 404
```

-----

#### 11\. Building a Simple REST API with FastAPI (CRUD Example)

Let's adapt our `Book` example to FastAPI, leveraging Pydantic.

```python
from fastapi import FastAPI, HTTPException, status
from pydantic import BaseModel, Field
import uvicorn # Used to run directly from script

app = FastAPI(
    title="Simple Book API",
    description="A basic REST API for managing books, demonstrating FastAPI features."
)

# In-memory "database"
books_db = {
    1: {"title": "The Hitchhiker's Guide to the Galaxy", "author": "Douglas Adams"},
    2: {"title": "1984", "author": "George Orwell"},
    3: {"title": "Pride and Prejudice", "author": "Jane Austen"}
}
current_book_id = 3 # Keep track of next ID

# Pydantic Model for incoming Book creation requests
class BookCreate(BaseModel):
    title: str = Field(min_length=1, max_length=100)
    author: str = Field(min_length=1, max_length=50)

# Pydantic Model for updating a Book (all fields optional)
class BookUpdate(BaseModel):
    title: str | None = Field(None, min_length=1, max_length=100)
    author: str | None = Field(None, min_length=1, max_length=50)

# Pydantic Model for a full Book response (includes ID)
class BookResponse(BaseModel):
    id: int
    title: str
    author: str

# --- ROUTES FOR BOOKS RESOURCE ---

# GET all books
@app.get("/books", response_model=list[BookResponse], summary="Retrieve all books")
async def get_all_books():
    # Convert dict of dicts to list of BookResponse models
    return [BookResponse(id=book_id, **book_data) for book_id, book_data in books_db.items()]

# GET a single book by ID
@app.get("/books/{book_id}", response_model=BookResponse, summary="Retrieve a single book by ID")
async def get_book(book_id: int):
    book_data = books_db.get(book_id)
    if not book_data:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Book not found")
    return BookResponse(id=book_id, **book_data)

# POST a new book
@app.post("/books", response_model=BookResponse, status_code=status.HTTP_201_CREATED, summary="Create a new book")
async def create_book(book: BookCreate): # Request body will be validated against BookCreate
    global current_book_id
    current_book_id += 1
    new_book_id = current_book_id
    books_db[new_book_id] = book.model_dump() # Convert Pydantic model back to dict
    return BookResponse(id=new_book_id, **books_db[new_book_id])

# PUT to update a book by ID (full replacement)
@app.put("/books/{book_id}", response_model=BookResponse, summary="Update an existing book by ID (full replacement)")
async def update_book(book_id: int, book: BookCreate): # Expecting full data
    if book_id not in books_db:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Book not found")
    books_db[book_id] = book.model_dump()
    return BookResponse(id=book_id, **books_db[book_id])

# PATCH to partially update a book by ID
@app.patch("/books/{book_id}", response_model=BookResponse, summary="Partially update an existing book by ID")
async def partial_update_book(book_id: int, updates: BookUpdate): # Expecting partial data
    if book_id not in books_db:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Book not found")

    existing_book_data = books_db[book_id]
    update_data = updates.model_dump(exclude_unset=True) # Only get fields that were actually provided

    # Apply updates to existing data
    existing_book_data.update(update_data)
    books_db[book_id] = existing_book_data # Update the "database"

    return BookResponse(id=book_id, **books_db[book_id])


# DELETE a book by ID
@app.delete("/books/{book_id}", status_code=status.HTTP_204_NO_CONTENT, summary="Delete a book by ID")
async def delete_book(book_id: int):
    if book_id not in books_db:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Book not found")
    del books_db[book_id]
    return # FastAPI automatically sends 204 No Content for functions that don't return anything with 204 status_code

if __name__ == "__main__":
    uvicorn.run(app, host="127.0.0.1", port=8000, reload=True) # Run directly from script
```

**Key FastAPI/Pydantic Features in this Example:**

  * **Pydantic Models (`BaseModel`):**
      * `BookCreate`: Defines the expected structure for creating a book. Fields like `title` and `author` are `str` and implicitly required. `Field(min_length=1)` adds a validation constraint.
      * `BookUpdate`: All fields are `Optional[str]` (or `str | None` in Python 3.10+) for partial updates.
      * `BookResponse`: Defines the structure of the data sent back to the client, including the `id`.
  * **`response_model`:** The `response_model` argument in `app.get`, `app.post`, `app.put`, `app.patch` decorators tells FastAPI what schema the *response* should conform to. This automatically serializes your Python dict/object to the specified Pydantic model and generates documentation.
  * **`status_code`:** Directly sets the HTTP status code for a successful response.
  * **`Field`:** From Pydantic, allows adding extra validation (like `min_length`, `max_length`, `gt`, `lt`, etc.) and metadata (like `description`).
  * **`model_dump(exclude_unset=True)`:** When updating, `exclude_unset=True` ensures that only fields that were *actually provided* in the request body are included in the `update_data` dictionary. This is crucial for PATCH operations.
  * **`HTTPException`:** Used to raise specific HTTP error responses with appropriate status codes and detail messages.

-----

#### Your Turn to Practice:

1.  **Refactor Task Manager to FastAPI (`fastapi_task_manager.py`):**

      * Take your `task_manager.py` Flask API.
      * Convert it to FastAPI.
      * Define Pydantic models for `TaskCreate`, `TaskUpdate`, and `TaskResponse` (similar to `BookCreate`/`BookUpdate`/`BookResponse`).
      * Implement the `GET`, `POST`, `PUT`, `PATCH` (for status updates, for example), and `DELETE` endpoints.
      * Ensure proper type hints are used everywhere.
      * Test the API using `uvicorn` and check the automatic `/docs` and `/redoc` pages.

2.  **Async External API Integration (Optional, but highly recommended for backend skills):**

      * Build a FastAPI endpoint `GET /joke` that fetches a random joke from a public API (e.g., `https://v2.jokeapi.dev/joke/Any?type=single`).
      * Use `httpx.AsyncClient` for the asynchronous HTTP request.
      * Return the joke as a JSON response.
      * This demonstrates combining FastAPI's async capabilities with external I/O.

This transition to FastAPI is a significant step towards modern, high-performance API development. Master these concepts, and you'll be well-equipped for building robust backend services.

When you're ready, we'll move on to **Phase 3, Step 4: Database Integration (SQLAlchemy)**.