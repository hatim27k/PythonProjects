Alright, let's move on to **Phase 1, Step 4: Functions & Scope**.

This is a critical area for structuring your code and understanding how data is accessed and modified within different parts of your program. Python's approach to functions is quite flexible and powerful, especially with its argument handling.

-----

### Phase 1, Step 4: Functions & Scope

#### 1\. Defining Functions (`def`)

**Python:**

  * Functions are defined using the `def` keyword, followed by the function name, parentheses `()`, and a colon `:`.
  * The function body is indented, just like `if` or `for` blocks.
  * Functions can optionally return values using the `return` keyword. If no `return` statement is present, the function implicitly returns `None`.

**C++ / Java Comparison:**

  * Similar to defining methods in a class or free functions in C++.
  * No explicit return type declaration (Python handles this dynamically).
  * No curly braces; indentation defines the body.

**Examples:**

```python
# Simple function with no arguments, no return value
def greet():
    print("Hello, world!")

greet() # Calling the function

# Function with arguments and a return value
def add(a, b):
    result = a + b
    return result

sum_result = add(5, 3)
print(f"Sum: {sum_result}")

# Function returning multiple values (as a tuple)
def get_user_info():
    name = "Alice"
    age = 30
    return name, age # Returns a tuple (name, age)

user_name, user_age = get_user_info() # Tuple unpacking
print(f"User Name: {user_name}, User Age: {user_age}")

# Function with no explicit return (returns None implicitly)
def do_nothing():
    pass # 'pass' is a placeholder for an empty block

result_none = do_nothing()
print(f"Return value of do_nothing: {result_none}") # Output: None
```

-----

#### 2\. Argument Passing

Python offers very flexible ways to pass arguments to functions.

##### a. Positional Arguments

  * Arguments are matched to parameters based on their order. This is the default and most common way.

<!-- end list -->

```python
def describe_pet(animal_type, pet_name):
    print(f"I have a {animal_type}.")
    print(f"Its name is {pet_name}.")

describe_pet("dog", "Buddy") # Positional arguments
# describe_pet("Buddy", "dog") # Order matters! This would be incorrect for the logic
```

##### b. Keyword Arguments

  * You can explicitly name the parameters when calling the function. This improves readability and allows you to pass arguments in any order.

<!-- end list -->

```python
def describe_pet(animal_type, pet_name):
    print(f"I have a {animal_type}.")
    print(f"Its name is {pet_name}.")

describe_pet(pet_name="Buddy", animal_type="dog") # Keyword arguments
```

**C++ / Java Comparison:**

  * C++ has named arguments/designated initializers in C++20. Java primarily uses positional arguments. Python's keyword arguments are a powerful distinction.

##### c. Default Arguments (Optional Parameters)

  * You can specify default values for parameters. If a caller doesn't provide a value for that parameter, the default is used.
  * **Important Rule:** Parameters with default values *must* come after parameters without default values.

<!-- end list -->

```python
def greet_user(name, message="Hello"): # 'message' has a default value
    print(f"{message}, {name}!")

greet_user("Alice")              # Uses default message: "Hello, Alice!"
greet_user("Bob", "Good morning") # Overrides default: "Good morning, Bob!"
```

**C++ / Java Comparison:**

  * C++ supports default arguments. Java traditionally doesn't (you'd use method overloading, though recent versions have builder patterns or optional parameters through libraries).

##### d. Arbitrary Positional Arguments (`*args`)

  * Sometimes you don't know in advance how many positional arguments a function will receive. The `*args` syntax allows a function to accept a variable number of positional arguments, which are collected into a `tuple`.

<!-- end list -->

```python
def sum_all_numbers(*numbers): # 'numbers' will be a tuple
    total = 0
    for num in numbers:
        total += num
    return total

print(f"Sum of (1, 2, 3): {sum_all_numbers(1, 2, 3)}") # Output: 6
print(f"Sum of (10, 20): {sum_all_numbers(10, 20)}")   # Output: 30
print(f"Sum of nothing: {sum_all_numbers()}")           # Output: 0
```

**C++ / Java Comparison:**

  * Similar to C++ variadic functions or Java's varargs (`...` syntax).

##### e. Arbitrary Keyword Arguments (`**kwargs`)

  * Similarly, `**kwargs` allows a function to accept a variable number of keyword arguments, which are collected into a `dictionary`.

<!-- end list -->

```python
def print_profile(**details): # 'details' will be a dictionary
    print("User Profile:")
    for key, value in details.items():
        print(f"  {key.replace('_', ' ').title()}: {value}") # Nicer output

print_profile(name="Carol", age=25, city="London")
# Output:
# User Profile:
#   Name: Carol
#   Age: 25
#   City: London

print_profile(product="Laptop", price=1200, category="Electronics", brand="Dell")
```

**C++ / Java Comparison:**

  * No direct equivalent. In Java, you'd typically pass a `Map` or use a builder pattern.

##### f. Order of Arguments

When combining different argument types, the order matters:
`positional_args`, `*args`, `keyword_only_args`, `**kwargs`

```python
def complex_function(a, b, *args, kw_only1, kw_only2=10, **kwargs):
    print(f"a: {a}, b: {b}")
    print(f"args: {args}")
    print(f"kw_only1: {kw_only1}, kw_only2: {kw_only2}")
    print(f"kwargs: {kwargs}")

# complex_function(1, 2, 3, 4, 5, kw_only1="hello", extra_param="world")
# Raises an error: "kw_only1" must be a keyword argument because it comes after *args
# You need to specify positional-only arguments using '/' (Python 3.8+) or just by position if before *args

# Correct way:
def complex_function_corrected(a, b, *args, kw_only1, kw_only2=10, **kwargs):
    print(f"a: {a}, b: {b}")
    print(f"args: {args}")
    print(f"kw_only1: {kw_only1}, kw_only2: {kw_only2}")
    print(f"kwargs: {kwargs}")

complex_function_corrected(1, 2, 3, 4, 5, kw_only1="hello", extra_param="world")
# Output:
# a: 1, b: 2
# args: (3, 4, 5)
# kw_only1: hello, kw_only2: 10
# kwargs: {'extra_param': 'world'}

# Example with explicit positional-only arguments (Python 3.8+)
# Arguments before / are positional-only
# Arguments after * are keyword-only
def profile(name, /, age, *, city, occupation="Developer"):
    print(f"Name: {name}")
    print(f"Age: {age}")
    print(f"City: {city}")
    print(f"Occupation: {occupation}")

profile("David", 28, city="Berlin") # name and age must be positional
# profile(name="David", age=28, city="Berlin") # This would cause an error for 'name' as it's positional-only
```

-----

#### 3\. Variable Scope Rules (LEGB Rule)

Python uses the LEGB rule for determining the order in which namespaces are searched for identifier (variable, function, class, module) lookups:

1.  **L (Local):** Variables defined inside the current function.
2.  **E (Enclosing function locals):** Variables in the local scope of any enclosing (outer) functions. This applies to nested functions.
3.  **G (Global):** Variables defined at the top level of a module (file).
4.  **B (Built-in):** Names pre-assigned in Python (e.g., `print`, `len`, `str`, `True`, `None`).

**C++ / Java Comparison:**

  * Similar to block scope, method scope, and class/static scope, but with a clear hierarchy in Python for nested functions.

**Examples:**

```python
# Global scope
global_var = "I am a global variable."

def outer_function():
    # Enclosing scope (for inner_function)
    enclosing_var = "I am from the outer function."

    def inner_function():
        # Local scope
        local_var = "I am a local variable."
        print(f"Inside inner_function:")
        print(f"  Local: {local_var}")
        print(f"  Enclosing: {enclosing_var}") # Can access enclosing scope
        print(f"  Global: {global_var}")     # Can access global scope
        # print(f"  Built-in example: {len('test')}") # Can access built-ins

    inner_function()
    # print(local_var) # Error: local_var is not defined in outer_function's scope

print(f"Outside functions - Global: {global_var}")
outer_function()
# print(enclosing_var) # Error: enclosing_var is not defined in global scope
```

##### Modifying Global Variables (`global` keyword)

  * By default, assigning to a variable inside a function creates a *new local variable*.
  * To modify a global variable from inside a function, you must explicitly use the `global` keyword.

<!-- end list -->

```python
counter = 0 # Global variable

def increment_bad():
    # This creates a NEW local 'counter', doesn't modify the global one
    counter = 1
    print(f"Local counter inside bad: {counter}")

def increment_good():
    global counter # Declare intent to modify the global 'counter'
    counter += 1
    print(f"Global counter inside good: {counter}")

print(f"Global counter before bad: {counter}") # 0
increment_bad() # Creates local counter = 1
print(f"Global counter after bad: {counter}")  # Still 0

print(f"\nGlobal counter before good: {counter}") # 0
increment_good() # Modifies global counter to 1
print(f"Global counter after good: {counter}")  # 1
increment_good() # Modifies global counter to 2
print(f"Global counter after good again: {counter}") # 2
```

##### Modifying Enclosing Variables (`nonlocal` keyword)

  * Introduced in Python 3, `nonlocal` allows you to modify a variable in an immediately enclosing (non-global) scope.

<!-- end list -->

```python
def outer_function_with_nonlocal():
    message = "Outer message"

    def inner_function_with_nonlocal():
        nonlocal message # Declare intent to modify 'message' from outer_function_with_nonlocal's scope
        message = "Inner modified outer message"
        print(f"Inside inner_function (modified): {message}")

    print(f"Before inner_function call: {message}")
    inner_function_with_nonlocal()
    print(f"After inner_function call: {message}")

outer_function_with_nonlocal()
```

-----

#### Your Turn to Practice:

1.  **Simple Calculator Functions (`calculator.py`):**

      * Define four functions: `add`, `subtract`, `multiply`, and `divide`.
      * Each function should take two numerical arguments and return the result.
      * For `divide`, handle the case of division by zero (e.g., return `None` or raise a custom error message if you want to be advanced).
      * Call each function with sample numbers and print the results.

2.  **User Greeter with Defaults (`greeter.py`):**

      * Define a function `create_greeting(name, salutation="Hello", excited=False)`.
      * The function should return a greeting string like "Hello, Alice\!" or "Good morning, Bob\!\!\!" if `excited` is `True`.
      * Call the function with:
          * Only `name`.
          * `name` and `salutation`.
          * `name`, `salutation`, and `excited` (both `True` and `False`).
          * Use keyword arguments for some calls.

3.  **Dynamic Average Calculator (`average.py`):**

      * Define a function `calculate_average(*numbers)`.
      * This function should accept any number of numerical arguments.
      * It should return the average of these numbers.
      * Handle the case where no numbers are provided (e.g., return 0 or `None`).

4.  **Configure Profile with Arbitrary Details (`config_profile.py`):**

      * Define a function `configure_profile(username, **kwargs)`.
      * The function should print the `username`.
      * Then, iterate through the `kwargs` (key-value pairs) and print each additional configuration detail (e.g., "Email: example@example.com", "Location: City").
      * Call this function with `username` and a few different keyword arguments (e.g., `email`, `age`, `theme`).

5.  **Counter Function (Scope Challenge - Optional but good for understanding `nonlocal`):**

      * Define an `outer` function that initializes a `count` variable to 0.
      * Inside `outer`, define an `inner` function called `increment`.
      * The `increment` function should use `nonlocal` to increase the `count` from the `outer` function's scope by 1.
      * The `outer` function should return the `increment` function.
      * Call `increment` multiple times outside the `outer` function to observe the `count` increasing. (This is a basic example of a closure, which we'll discuss more later).

Share your solutions for these exercises. Once you're comfortable with functions and scope, we'll proceed to **Object-Oriented Programming (OOP) in Python**.