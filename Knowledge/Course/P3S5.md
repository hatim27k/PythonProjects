Let's move into **Phase 3, Step 5: Authentication and Authorization**. This is a critical step for securing your backend APIs, ensuring that only legitimate and authorized users can access your resources.

-----

### Phase 3, Step 5: Authentication and Authorization

#### 1\. Authentication vs. Authorization

These terms are often confused but are distinct:

  * **Authentication:** *Verifying who someone is.*
      * "Are you who you say you are?"
      * Examples: Logging in with a username/password, using an API key, verifying a digital certificate.
      * Outcome: Establishes a user's identity.
  * **Authorization:** *Determining what someone is allowed to do.*
      * "What are you allowed to access or perform?"
      * Examples: A regular user can view their own profile but not an admin's. An admin can delete any user.
      * Outcome: Grants or denies access to resources or actions based on identity and roles/permissions.

In a typical API flow, authentication happens first. Once a user is authenticated, their identity is known, and then authorization checks determine their access rights.

#### 2\. Common Authentication Methods for APIs

  * **API Keys:**
      * **Concept:** A simple string token (like a long password) sent with each request.
      * **Pros:** Easy to implement, good for machine-to-machine communication or public APIs with rate limits.
      * **Cons:** Less secure (can be easily stolen if not protected, no inherent expiration), difficult to revoke granularly per user. Not suitable for user-facing applications.
  * **Session-based Authentication:**
      * **Concept:** After login, the server creates a session (stores user state on the server) and sends a session ID (cookie) to the client. The client sends the cookie with subsequent requests.
      * **Pros:** Common in traditional web applications, built-in browser support.
      * **Cons:** Requires server-side state (harder to scale horizontally), susceptible to CSRF attacks without protection, not ideal for mobile apps or third-party clients.
  * **Token-based Authentication (e.g., JWT):**
      * **Concept:** After login, the server issues a cryptographic token (e.g., JWT) to the client. The client stores this token and sends it with each subsequent request (usually in an `Authorization` header). The server validates the token to authenticate the user *without* needing to query a database on every request.
      * **Pros:** **Stateless** (server doesn't store session state, making it highly scalable), works well with mobile apps and single-page applications, cross-domain friendly, can carry user information in the token's payload.
      * **Cons:** Tokens can be intercepted (require HTTPS), JWTs are "signed" but not "encrypted" by default (sensitive data shouldn't be in payload), token revocation is trickier without a centralized blacklist or short expiry times.

We will focus on **Token-based Authentication using JWTs** as it's the de-facto standard for modern RESTful APIs.

#### 3\. JSON Web Tokens (JWT)

**What is a JWT?**
A JWT is a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is digitally signed using a JSON Web Signature (JWS) or encrypted using JSON Web Encryption (JWE).

**Structure of a JWT:**
A JWT typically looks like three base64url-encoded parts separated by dots: `header.payload.signature`

1.  **Header:** (Base64Url-encoded JSON)

      * `alg`: Algorithm used for signing (e.g., HS256, RS256).
      * `typ`: Type of token (always "JWT").
      * Example: `{"alg": "HS256", "typ": "JWT"}`

2.  **Payload:** (Base64Url-encoded JSON)

      * Contains "claims" about the entity (typically, the user) and additional data.
      * **Registered Claims (optional but recommended):**
          * `iss`: Issuer (who issued the token).
          * `exp`: Expiration time (when the token expires).
          * `sub`: Subject (who the token refers to, usually user ID).
          * `aud`: Audience (who the token is for).
          * `iat`: Issued At (when the token was issued).
      * **Public Claims:** Custom claims, but collisions must be avoided.
      * **Private Claims:** Custom claims agreed upon by the parties.
      * Example: `{"sub": "1234567890", "name": "John Doe", "iat": 1516239022, "exp": 1516242622}`

3.  **Signature:** (Base64Url-encoded)

      * Created by taking the base64url-encoded header, the base64url-encoded payload, concatenating them with a dot, and then hashing the result with the secret key and the algorithm specified in the header.
      * `HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret_key)`
      * The signature is used to verify that the sender of the JWT is who it says it is and that the message hasn't been tampered with.

**How it works in API Authentication:**

1.  **Login:** User sends username/password to `/token` or `/login` endpoint.
2.  **Issue Token:** Server validates credentials. If valid, it generates a JWT, signs it with a secret key, and sends it back to the client.
3.  **Send Token:** Client stores the JWT (e.g., in local storage, cookies). For subsequent requests to protected endpoints, the client includes the JWT, typically in the `Authorization` header as a `Bearer` token: `Authorization: Bearer <your-jwt>`.
4.  **Validate Token:** Server receives the request. It extracts the JWT, verifies its signature using the same secret key (ensuring it's not tampered with), checks its expiration time, and optionally other claims. If valid, the user is authenticated, and their ID/roles can be extracted from the payload. The request is then processed.

**Security Considerations:**

  * **HTTPS is mandatory:** JWTs are often signed but not encrypted. If sent over HTTP, the payload (and thus user info) can be read.
  * **Secret Key Security:** The secret key used to sign JWTs *must* be kept secure on the server side. Compromise of the secret allows an attacker to forge tokens.
  * **Expiration:** Set short expiry times for tokens to reduce the window of opportunity if a token is stolen.
  * **No Central Revocation (by default):** If a JWT is issued, it's valid until it expires. Revoking a single token before its expiry requires extra mechanisms (e.g., a blacklist/blocklist stored in a fast cache like Redis, or using refresh tokens with shorter access tokens). For this basic example, we won't implement refresh tokens.

-----

#### 4\. Implementing JWT Authentication in FastAPI

We'll use:

  * `python-jose` for JWT encoding/decoding.
  * `passlib[bcrypt]` for secure password hashing.
  * FastAPI's `Security` and `OAuth2PasswordBearer` for managing authentication flows.

**Installations:**

```bash
pip install "python-jose[cryptography]" "passlib[bcrypt]"
```

**Project Structure (Updates):**

```
my_fastapi_app/
├── main.py
├── database.py
├── models.py
├── schemas.py
├── crud.py
└── auth.py  <-- NEW FILE for security logic
```

**a. `auth.py` - Security Utilities:**

```python
# auth.py
from datetime import datetime, timedelta, timezone
from typing import Annotated

from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from passlib.context import CryptContext

# --- Configuration ---
# You should get this from environment variables in production!
SECRET_KEY = "your-super-secret-key" # CHANGE THIS IN PRODUCTION
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30 # How long access tokens are valid

# --- Password Hashing ---
# Used for securely hashing and verifying passwords
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

# --- JWT Token Generation ---
def create_access_token(data: dict, expires_delta: timedelta | None = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

# --- OAuth2PasswordBearer for Token Extraction ---
# This class handles extracting the token from the "Authorization: Bearer <token>" header
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token") # "tokenUrl" is the endpoint for getting a token

# --- Dependency to Get Current User from Token ---
async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub") # 'sub' claim usually holds the user identifier
        if username is None:
            raise credentials_exception
        # In a real app, you'd fetch the user from the DB here to ensure they still exist and are active
        # For this demo, we'll just return a dummy user or username
        return username # For now, just return the username/email from the token
    except JWTError:
        raise credentials_exception

```

**b. `models.py` (No changes needed if using `User` as defined previously):**

```python
# models.py (no changes)
from sqlalchemy import Column, Integer, String, Boolean, ForeignKey
from sqlalchemy.orm import relationship
from .database import Base

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True)
    hashed_password = Column(String) # Store hashed passwords!
    is_active = Column(Boolean, default=True)
    items = relationship("Item", back_populates="owner")

class Item(Base):
    __tablename__ = "items"
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, index=True)
    description = Column(String, index=True)
    owner_id = Column(Integer, ForeignKey("users.id"))
    owner = relationship("User", back_populates="items")
```

**c. `schemas.py` (Add new schemas for login/token/user details):**

```python
# schemas.py
from pydantic import BaseModel, EmailStr

# Base schemas (common fields for creation/update)
class ItemBase(BaseModel):
    title: str
    description: str | None = None

class UserBase(BaseModel):
    email: EmailStr

# Schemas for creating entities
class ItemCreate(ItemBase):
    pass

class UserCreate(UserBase):
    password: str # Password is required for creation

# Schemas for responses (include ID and related fields)
class Item(ItemBase):
    id: int
    owner_id: int
    class Config:
        from_attributes = True

class User(UserBase):
    id: int
    is_active: bool
    items: list[Item] = []
    class Config:
        from_attributes = True

# --- New Schemas for Authentication ---
class Token(BaseModel):
    access_token: str
    token_type: str = "bearer" # Standard for JWTs

class TokenData(BaseModel):
    username: str | None = None # This will store the 'sub' claim from the JWT
```

**d. `crud.py` (Update `create_user` to hash passwords):**

```python
# crud.py
from sqlalchemy.orm import Session
from . import models # No schemas import needed here
from .auth import get_password_hash # Import hashing utility

# --- User CRUD ---
def get_user(db: Session, user_id: int):
    return db.query(models.User).filter(models.User.id == user_id).first()

def get_user_by_email(db: Session, email: str):
    return db.query(models.User).filter(models.User.email == email).first()

def get_users(db: Session, skip: int = 0, limit: int = 100):
    return db.query(models.User).offset(skip).limit(limit).all()

def create_user(db: Session, email: str, password: str): # Now receives plain password
    hashed_password = get_password_hash(password) # Hash the password
    db_user = models.User(email=email, hashed_password=hashed_password)
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

def update_user(db: Session, user_id: int, new_email: str = None, is_active: bool = None):
    db_user = get_user(db, user_id)
    if db_user:
        if new_email:
            db_user.email = new_email
        if is_active is not None:
            db_user.is_active = is_active
        db.commit()
        db.refresh(db_user)
    return db_user

def delete_user(db: Session, user_id: int):
    db_user = get_user(db, user_id)
    if db_user:
        db.delete(db_user)
        db.commit()
        return True
    return False

# --- Item CRUD ---
def get_items(db: Session, skip: int = 0, limit: int = 100):
    return db.query(models.Item).offset(skip).limit(limit).all()

def create_user_item(db: Session, item_title: str, item_description: str, user_id: int):
    db_item = models.Item(title=item_title, description=item_description, owner_id=user_id)
    db.add(db_item)
    db.commit()
    db.refresh(db_item)
    return db_item

def get_item(db: Session, item_id: int):
    return db.query(models.Item).filter(models.Item.id == item_id).first()
```

**e. `main.py` (Add login/token endpoints and protect existing routes):**

```python
# main.py
from typing import Annotated # Python 3.9+ for List, Dict etc. used in type hints

from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm # For standard form login
from sqlalchemy.orm import Session
import uvicorn

from . import crud, models, schemas, auth # Import auth utilities
from .database import SessionLocal, engine, Base

# Create database tables (in a real app, use Alembic for migrations)
Base.metadata.create_all(bind=engine)

app = FastAPI(title="FastAPI Auth Demo")

# Dependency to get a database session
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# Dependency to get the current authenticated user (based on JWT)
async def get_current_active_user(
    current_username: Annotated[str, Depends(auth.get_current_user)],
    db: Session = Depends(get_db)
):
    # In a real app, retrieve the full user object from DB using current_username
    # For this demo, let's just create a dummy user object
    user = crud.get_user_by_email(db, email=current_username)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    if not user.is_active:
        raise HTTPException(status_code=400, detail="Inactive user")
    return user # Return the actual User object from the DB

# --- AUTHENTICATION ENDPOINTS ---

# User Registration
@app.post("/register/", response_model=schemas.User, summary="Register a new user")
async def register_user(user: schemas.UserCreate, db: Session = Depends(get_db)):
    db_user = crud.get_user_by_email(db, email=user.email)
    if db_user:
        raise HTTPException(status_code=400, detail="Email already registered")
    # Store hashed password
    return crud.create_user(db=db, email=user.email, password=user.password)

# User Login (Get Token)
@app.post("/token", response_model=schemas.Token, summary="Authenticate user and get access token")
async def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    db: Session = Depends(get_db)
):
    user = crud.get_user_by_email(db, email=form_data.username)
    if not user or not auth.verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = auth.timedelta(minutes=auth.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = auth.create_access_token(
        data={"sub": user.email}, # 'sub' claim is the subject, usually a unique identifier like email
        expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}


# --- PROTECTED ENDPOINTS ---

# Example: Get current user's profile (requires authentication)
@app.get("/users/me/", response_model=schemas.User, summary="Get current authenticated user's details")
async def read_users_me(current_user: Annotated[models.User, Depends(get_current_active_user)]):
    return current_user # The 'current_user' is the User object returned by get_current_active_user

# Modify existing User/Item endpoints to require authentication
# (Only authenticated users can access these)

@app.post("/users/", response_model=schemas.User, status_code=status.HTTP_201_CREATED, summary="Create a new user (admin only example)")
async def create_user_protected(
    user: schemas.UserCreate,
    db: Session = Depends(get_db),
    current_user: Annotated[models.User, Depends(get_current_active_user)] = None # Make it optional for now, or require specific role
):
    if current_user is None: # For demo, allow creation only if authenticated. For role-based, check roles here.
        raise HTTPException(status_code=403, detail="Not authenticated to create users directly")

    db_user = crud.get_user_by_email(db, email=user.email)
    if db_user:
        raise HTTPException(status_code=400, detail="Email already registered")
    return crud.create_user(db=db, email=user.email, password=user.password)

@app.get("/users/", response_model=list[schemas.User], summary="Retrieve all users (protected)")
async def read_users_protected(
    skip: int = 0, limit: int = 100,
    db: Session = Depends(get_db),
    current_user: Annotated[models.User, Depends(get_current_active_user)] # This makes the endpoint protected
):
    users = crud.get_users(db, skip=skip, limit=limit)
    return users

@app.get("/users/{user_id}", response_model=schemas.User, summary="Retrieve a user by ID (protected)")
async def read_user_protected(
    user_id: int,
    db: Session = Depends(get_db),
    current_user: Annotated[models.User, Depends(get_current_active_user)]
):
    db_user = crud.get_user(db, user_id=user_id)
    if db_user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return db_user

# Similarly, protect your item endpoints

@app.post("/users/{user_id}/items/", response_model=schemas.Item, status_code=status.HTTP_201_CREATED, summary="Create an item for a user (protected)")
async def create_item_for_user_protected(
    user_id: int,
    item: schemas.ItemCreate,
    db: Session = Depends(get_db),
    current_user: Annotated[models.User, Depends(get_current_active_user)]
):
    # Authorization: Only allow creating items for the currently authenticated user
    # For a simple demo, we'll check if the owner_id matches the authenticated user's email
    # A more robust check would involve fetching the user object from the DB to get their ID
    if current_user.email != crud.get_user(db, user_id).email: # This logic needs refinement in a real app
         raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Not authorized to create items for this user")

    db_user = crud.get_user(db, user_id=user_id)
    if db_user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return crud.create_user_item(db=db, item_title=item.title, item_description=item.description, user_id=user_id)

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000, reload=True)
```

**Testing the Authentication Flow:**

1.  **Start the app:** `uvicorn main:app --reload`
2.  **Access `/docs`:** Notice the "Authorize" button and the lock icons on protected endpoints.
3.  **Register a user:**
      * `POST http://127.0.0.1:8000/register/`
      * JSON Body: `{"email": "test@example.com", "password": "password123"}`
      * Expected: 201 Created, returns user object.
4.  **Try accessing protected endpoint (e.g., `/users/`) without token:**
      * `GET http://127.0.0.1:8000/users/`
      * Expected: 401 Unauthorized
5.  **Get an Access Token (Login):**
      * `POST http://127.0.0.1:8000/token`
      * Body (Form-urlencoded):
          * `username`: `test@example.com`
          * `password`: `password123`
      * Expected: 200 OK, returns `{"access_token": "...", "token_type": "bearer"}`. Copy the `access_token`.
6.  **Access protected endpoint with token:**
      * In Postman/Insomnia, add an `Authorization` header:
          * Key: `Authorization`
          * Value: `Bearer <YOUR_COPIED_ACCESS_TOKEN>`
      * `GET http://127.0.0.1:8000/users/`
      * Expected: 200 OK, returns list of users.
7.  **Try `GET http://127.0.0.1:8000/users/me/` with the token.**

#### 5\. Authorization (Basic Role-Based Access Control)

To implement authorization, you typically store a `role` (e.g., "user", "admin") or `permissions` (e.g., "can\_delete\_users", "can\_view\_reports") for each user in the database.

**Conceptual Steps:**

1.  **Add `role` column to `User` model:**
    ```python
    # models.py
    # ...
    class User(Base):
        # ...
        role = Column(String, default="user") # e.g., 'user', 'admin'
    ```
2.  **Update `User` schema:**
    ```python
    # schemas.py
    # ...
    class User(UserBase):
        # ...
        role: str
        class Config:
            from_attributes = True
    ```
3.  **Update `create_user` in `crud.py` to allow setting role (or default it).**
4.  **Create an `is_admin` dependency in `auth.py`:**
    ```python
    # auth.py
    # ...
    async def get_current_active_admin(current_user: Annotated[models.User, Depends(get_current_active_user)]):
        if current_user.role != "admin":
            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Not enough permissions")
        return current_user
    ```
5.  **Use the `get_current_active_admin` dependency on admin-only routes:**
    ```python
    # main.py
    # ...
    @app.delete("/admin/users/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
    async def delete_user_admin(
        user_id: int,
        db: Session = Depends(get_db),
        current_admin: Annotated[models.User, Depends(auth.get_current_active_admin)] # Requires admin role
    ):
        success = crud.delete_user(db, user_id)
        if not success:
            raise HTTPException(status_code=404, detail="User not found")
        return
    ```

-----

#### Your Turn to Practice:

1.  **Implement JWT Auth on Your Task Manager API (`fastapi_auth_tasks/`):**

      * Start with your `fastapi_task_manager` project.
      * Implement the JWT authentication system:
          * Add `auth.py` with password hashing, token creation, and `get_current_user` dependency.
          * Update `models.py` (`User` table needs `hashed_password`).
          * Update `schemas.py` (`Token`, `TokenData`, `UserCreate` with password).
          * Update `crud.py` (hash password in `create_user`).
          * In `main.py`:
              * Add `/register` and `/token` endpoints.
              * Protect **all** task management endpoints (`/tasks`, `/tasks/{id}`) using `Depends(auth.get_current_active_user)`.
              * Modify `POST /tasks` and `PUT /tasks/{id}` so that a task can only be created/updated by the authenticated user (i.e., associate the task with the `current_user.id`).
      * Test the entire flow: Register, login, get token, use token to create/read/update/delete tasks.

2.  **Implement Basic Authorization (Admin Tasks):**

      * Extend your `Task` model in `models.py` to include an `owner_id` (ForeignKey to `users.id`).
      * Modify your `TaskCreate` schema to *not* include `owner_id` (it will be set by the server).
      * In `POST /tasks`, retrieve `current_user` from the dependency and set `owner_id` of the new task to `current_user.id`.
      * For `PUT /tasks/{id}` and `DELETE /tasks/{id}`, add a check: ensure `current_user.id` matches the `owner_id` of the task. If not, raise `HTTPException` with `403 Forbidden`.
      * (Optional Advanced): Add a `role` field to your `User` model (`user` vs `admin`). Create a `get_current_active_admin` dependency. Create a new endpoint `DELETE /admin/tasks/{task_id}` that can only be accessed by an admin user (using `get_current_active_admin`).

This is a comprehensive task, but successfully completing it means you've built a secure, authenticated, and authorized API, which is a core requirement for almost any real-world backend service.

When you're ready, we'll move on to **Phase 3, Step 6: Asynchronous Background Tasks & Task Queues**, which is crucial for handling long-running operations.