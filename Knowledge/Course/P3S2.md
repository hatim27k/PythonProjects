Fantastic\! Let's now dive into **Phase 3: Web Frameworks & APIs**. This is where your Python knowledge starts to directly translate into building functional backend systems.

This phase will focus on:

  * Understanding what web frameworks are and why we use them.
  * A quick refresher on HTTP basics (crucial for APIs).
  * Getting hands-on with **Flask**, a lightweight and flexible web framework, to build your first API.
  * Learning about **RESTful API principles**, which are the backbone of modern web services.

-----

### Phase 3, Step 1: Introduction to Web Frameworks & HTTP Basics

#### 1\. What are Web Frameworks?

**Concept:**
A web framework is a collection of libraries and modules that provide a standardized way to build web applications and APIs. They handle many common tasks, allowing developers to focus on the unique logic of their application rather than reinventing the wheel.

**Why use them?**

  * **Speed up Development:** Provide pre-built components for routing, database interaction, templating, session management, etc.
  * **Maintainability:** Enforce structure and best practices, making code easier to understand and manage.
  * **Security:** Offer built-in protections against common web vulnerabilities (e.g., CSRF, XSS).
  * **Scalability:** Provide tools and patterns to help build applications that can handle increasing load.
  * **Community & Ecosystem:** Large communities mean abundant documentation, tutorials, and third-party extensions.

**Popular Python Web Frameworks:**

  * **Django:** A "batteries-included" full-stack framework. Great for complex, database-driven web applications. Comes with an ORM, admin panel, authentication, etc.
  * **Flask:** A "micro-framework." Provides only the essentials, giving developers more freedom and requiring them to choose their own tools for things like ORMs, forms, etc. Excellent for building APIs and smaller web services.
  * **FastAPI:** A modern, high-performance web framework for building APIs. Built on standard Python type hints, offering automatic data validation, serialization, and interactive API documentation (Swagger UI). Leverages `asyncio` for high concurrency.

For this phase, we'll start with **Flask** as it's excellent for grasping core API concepts without the full complexity of Django, and then we'll transition to **FastAPI** which is often preferred for modern, high-performance APIs.

-----

#### 2\. HTTP Basics: The Language of the Web

APIs primarily communicate over HTTP (Hypertext Transfer Protocol). Understanding its fundamentals is crucial.

**a. Request-Response Cycle:**

1.  **Client (e.g., web browser, mobile app, another server):** Sends an HTTP Request.
2.  **Server (your backend):** Receives the request, processes it, and sends back an HTTP Response.
3.  **Client:** Receives and interprets the response.

**b. HTTP Methods (Verbs):**
These indicate the desired action to be performed on a resource.

  * `GET`: Retrieve data from a specified resource. (Safe and idempotent - multiple identical requests have the same effect as a single one).
  * `POST`: Submit data to be processed to a specified resource. Often results in the creation of a new resource. (Not idempotent).
  * `PUT`: Update a specified resource with new data, or create it if it doesn't exist. (Idempotent).
  * `DELETE`: Delete a specified resource. (Idempotent).
  * `PATCH`: Apply partial modifications to a resource. (Not necessarily idempotent, depends on implementation).
  * `HEAD`: Same as `GET`, but retrieves only the headers (no response body).
  * `OPTIONS`: Describes the communication options for the target resource.

**c. HTTP Status Codes:**
A 3-digit number returned by the server, indicating the outcome of the request.

  * **1xx (Informational):** Request received, continuing process. (Rarely seen directly by users).
  * **2xx (Success):** The action was successfully received, understood, and accepted.
      * `200 OK`: Standard success for `GET`, `PUT`, `PATCH`.
      * `201 Created`: Resource successfully created (common for `POST`).
      * `204 No Content`: Successful request, but no content to return (common for `DELETE`).
  * **3xx (Redirection):** Further action needs to be taken to complete the request.
      * `301 Moved Permanently`
      * `302 Found`
  * **4xx (Client Error):** The request contains bad syntax or cannot be fulfilled.
      * `400 Bad Request`: General client error, e.g., invalid data format.
      * `401 Unauthorized`: Authentication is required (not logged in).
      * `403 Forbidden`: Authenticated, but no permission to access.
      * `404 Not Found`: The requested resource could not be found.
      * `405 Method Not Allowed`: HTTP method used is not supported for the resource.
      * `409 Conflict`: Request conflicts with current state of the resource (e.g., trying to create a resource that already exists with unique ID).
  * **5xx (Server Error):** The server failed to fulfill an apparently valid request.
      * `500 Internal Server Error`: Generic server-side error.
      * `502 Bad Gateway`
      * `503 Service Unavailable`

-----

### Phase 3, Step 2: Building Your First API with Flask

Let's get practical. Ensure you have a virtual environment activated for this.

**1. Installation:**

```bash
pip install Flask
```

**2. Basic "Hello, World\!" API (`app.py`):**

```python
from flask import Flask, jsonify, request

# Create a Flask application instance
app = Flask(__name__)

# A simple route for the root URL
@app.route('/')
def home():
    return "Hello, Flask API!"

# A route that returns JSON data
@app.route('/data')
def get_data():
    data = {
        "name": "API Example",
        "version": "1.0",
        "status": "active"
    }
    return jsonify(data) # jsonify converts Python dict to JSON response

# A route that handles query parameters
# Example: /greet?name=Alice&city=NewYork
@app.route('/greet')
def greet():
    name = request.args.get('name', 'Guest') # Get 'name' query param, default to 'Guest'
    city = request.args.get('city', 'Unknown City')
    return f"Hello, {name} from {city}!"

# A route that handles path parameters (dynamic URL segments)
# Example: /user/123
@app.route('/user/<int:user_id>') # <int:user_id> ensures user_id is an integer
def get_user(user_id):
    # In a real app, you'd fetch user data from a database
    users = {
        1: {"name": "Alice", "email": "alice@example.com"},
        2: {"name": "Bob", "email": "bob@example.com"}
    }
    user = users.get(user_id)
    if user:
        return jsonify(user)
    else:
        return jsonify({"message": "User not found"}), 404 # Return JSON and a 404 status code

# Run the Flask application
if __name__ == '__main__':
    # app.run() starts the development server
    # debug=True enables debug mode (auto-reloads on code changes, provides debugger)
    app.run(debug=True)
```

**How to Run:**

1.  Save the code as `app.py`.
2.  Open your terminal in the same directory.
3.  Ensure your virtual environment is activated.
4.  Run: `python app.py`
5.  You should see output similar to:
    ```
     * Serving Flask app 'app'
     * Debug mode: on
     WARNING: This is a development server. Do not use it in a production deployment.
     Use a production WSGI server instead.
     * Running on http://127.0.0.1:5000
     Press CTRL+C to quit
     * Restarting with stat
     * Debugger is active!
     * Debugger PIN: ...
    ```
6.  Open your browser or use a tool like Postman/Insomnia/curl to test the endpoints:
      * `http://127.0.0.1:5000/`
      * `http://127.0.0.1:5000/data`
      * `http://127.0.0.1:5000/greet?name=Alice&city=Dublin`
      * `http://127.0.0.1:5000/user/1`
      * `http://127.0.0.1:5000/user/99`

**Explanation of Flask Concepts in the Example:**

  * `Flask(__name__)`: Creates the Flask application instance. `__name__` helps Flask locate resources.
  * `@app.route('/')`: This is a decorator that associates the `home` function with the `/` URL path. When a `GET` request comes to `/`, the `home` function is executed.
  * `jsonify()`: A Flask helper function that converts a Python dictionary (or other data structures) into a JSON-formatted HTTP response. It also sets the `Content-Type` header to `application/json`.
  * `request`: A global object (or more accurately, a proxy to the current request object) provided by Flask, allowing you to access incoming request data like query parameters (`request.args`), form data (`request.form`), JSON body (`request.json`), headers (`request.headers`), etc.
  * Path Parameters (`/user/<int:user_id>`): Allow dynamic segments in URLs. `<int:user_id>` captures the segment and converts it to an integer, passing it as an argument to the function.
  * Returning Status Codes: You can return a tuple `(response_body, status_code)` from a view function to specify the HTTP status code.

-----

### 3\. RESTful API Principles

REST (Representational State Transfer) is an architectural style for designing networked applications. It's not a standard, but a set of guidelines. RESTful APIs are common because they are:

  * **Simple:** Easy to understand and implement.
  * **Scalable:** Statelessness aids horizontal scaling.
  * **Flexible:** Decouples client and server.

**Key Principles:**

  * **Resources:** Everything is a resource. Resources are identified by URLs (e.g., `/users`, `/products/123`).
  * **Statelessness:** Each request from a client to the server must contain all the information needed to understand the request. The server should not store any client context between requests. (This is crucial for scalability, as any server can handle any request).
  * **Uniform Interface:**
      * **Resource Identification:** Resources are identified by URIs.
      * **Resource Manipulation through Representations:** Clients interact with resources by sending representations (e.g., JSON, XML) in the request body.
      * **Self-Descriptive Messages:** Each message includes enough information to describe how to process the message. (e.g., HTTP methods, status codes, headers).
      * **Hypermedia as the Engine of Application State (HATEOAS):** Resources should contain links to related resources, guiding the client on how to proceed. (Often ignored in practical REST APIs, but a core principle).
  * **Client-Server Separation:** Client and server are independent. Changes on one side don't necessarily affect the other.
  * **Layered System:** A client cannot tell whether it is connected directly to the end server or to an intermediary.

**Mapping HTTP Methods to CRUD Operations:**

| Operation | HTTP Method | Endpoint Example       | Description                                  |
| :-------- | :---------- | :--------------------- | :------------------------------------------- |
| **C**reate | `POST`      | `/products`            | Create a new product.                        |
| **R**ead  | `GET`       | `/products`            | Get all products.                            |
| **R**ead  | `GET`       | `/products/{id}`       | Get a specific product by ID.                |
| **U**pdate | `PUT`       | `/products/{id}`       | Fully update a specific product.             |
| **U**pdate | `PATCH`     | `/products/{id}`       | Partially update a specific product.         |
| **D**elete | `DELETE`    | `/products/{id}`       | Delete a specific product.                   |

-----

### 4\. Building a Simple REST API with Flask (CRUD Example)

Let's expand `app.py` to manage a simple list of "books" in memory (no database yet).

```python
from flask import Flask, jsonify, request, abort

app = Flask(__name__)

# In-memory "database" for books
books = [
    {"id": 1, "title": "The Hitchhiker's Guide to the Galaxy", "author": "Douglas Adams"},
    {"id": 2, "title": "1984", "author": "George Orwell"},
    {"id": 3, "title": "Pride and Prejudice", "author": "Jane Austen"}
]
next_book_id = 4 # Simple ID management

# --- ROUTES FOR BOOKS RESOURCE ---

# GET all books
# POST a new book
@app.route('/books', methods=['GET', 'POST'])
def handle_books():
    if request.method == 'GET':
        return jsonify(books)
    elif request.method == 'POST':
        if not request.json or not 'title' in request.json or not 'author' in request.json:
            abort(400, description="Missing 'title' or 'author' in request body.") # Bad Request

        new_book = {
            'id': next_book_id,
            'title': request.json['title'],
            'author': request.json['author']
        }
        global next_book_id # Needed to modify global variable
        next_book_id += 1
        books.append(new_book)
        return jsonify(new_book), 201 # 201 Created

# GET a single book by ID
# PUT to update a book by ID
# DELETE a book by ID
@app.route('/books/<int:book_id>', methods=['GET', 'PUT', 'DELETE'])
def handle_single_book(book_id):
    book = next((b for b in books if b['id'] == book_id), None) # Find book by ID
    if not book:
        abort(404, description="Book not found.") # Not Found

    if request.method == 'GET':
        return jsonify(book)

    elif request.method == 'PUT':
        if not request.json or not 'title' in request.json or not 'author' in request.json:
            abort(400, description="Missing 'title' or 'author' in request body for update.")

        book['title'] = request.json['title']
        book['author'] = request.json['author']
        return jsonify(book) # 200 OK by default

    elif request.method == 'DELETE':
        global books # Needed to modify global list
        books = [b for b in books if b['id'] != book_id] # Filter out the deleted book
        return jsonify({"message": f"Book with ID {book_id} deleted."}), 204 # No Content

if __name__ == '__main__':
    app.run(debug=True)
```

**Testing the CRUD API:**

Use Postman, Insomnia, or `curl` in your terminal:

  * **GET all books:**
    `GET http://127.0.0.1:5000/books`
    (Expected: List of all books)

  * **POST a new book:**
    `POST http://127.0.0.1:5000/books`
    Body (JSON): `{"title": "Dune", "author": "Frank Herbert"}`
    (Expected: 201 Created, with the new book's details)

  * **GET a specific book:**
    `GET http://127.0.0.1:5000/books/1`
    (Expected: Details for book with ID 1)

  * **PUT to update a book:**
    `PUT http://127.0.0.1:5000/books/2`
    Body (JSON): `{"title": "Nineteen Eighty-Four (Updated)", "author": "George Orwell"}`
    (Expected: 200 OK, with updated book details)

  * **DELETE a book:**
    `DELETE http://127.0.0.1:5000/books/3`
    (Expected: 204 No Content)

  * **Test error cases:**

      * `GET http://127.0.0.1:5000/books/999` (Expected: 404 Not Found)
      * `POST http://127.0.0.1:5000/books` with missing fields in JSON (Expected: 400 Bad Request)

-----

#### Your Turn to Practice:

1.  **Build a Basic Task Manager API (`task_manager.py`):**
      * Create a new Flask application.
      * Set up an in-memory list of "tasks," where each task is a dictionary with `id`, `title`, `description`, `status` (e.g., "pending", "completed").
      * Implement the following RESTful endpoints:
          * `GET /tasks`: Retrieve all tasks.
          * `GET /tasks/<int:task_id>`: Retrieve a single task by ID. Return 404 if not found.
          * `POST /tasks`: Create a new task. The request body should contain `title` and `description`. Assign a unique `id` and default `status` ("pending"). Return 201 Created. Handle missing `title` or `description` with a 400 Bad Request.
          * `PUT /tasks/<int:task_id>`: Update an existing task. Allow updating `title`, `description`, and `status`. Return 404 if task not found, 400 if required fields are missing/invalid.
          * `DELETE /tasks/<int:task_id>`: Delete a task. Return 204 No Content on success, 404 if task not found.
      * Test all endpoints using `curl` or Postman.

This hands-on exercise with Flask will solidify your understanding of API development. When you're ready, we'll move on to **FastAPI**, which is a more modern choice for high-performance APIs.