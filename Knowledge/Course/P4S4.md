Let's talk about automating your development and deployment process\! We're now diving into **Phase 4, Step 4: CI/CD (Continuous Integration/Continuous Delivery)**.

CI/CD pipelines are the backbone of modern software development, enabling faster, more reliable, and more frequent software releases.

-----

### Phase 4, Step 4: CI/CD (Continuous Integration/Continuous Delivery)

#### 1\. What is CI/CD?

CI/CD represents a set of practices that automate the stages of software delivery.

  * **Continuous Integration (CI):**

      * **Goal:** To merge all developers' working copies to a shared mainline several times a day.
      * **Process:** Every time a developer pushes code to the version control system (e.g., Git), an automated build is triggered. This build compiles the code (if necessary), runs unit and integration tests, and creates an artifact (e.g., a Docker image).
      * **Benefit:** Catches integration issues and bugs early, leading to a more stable codebase.

  * **Continuous Delivery (CD):**

      * **Goal:** To ensure that the software can be released to production at any time.
      * **Process:** Extends CI by automatically deploying the verified build artifact to a staging or testing environment after successful CI. This allows for further manual or automated testing before a human decides to deploy to production.
      * **Benefit:** Accelerates the release process and makes releases predictable.

  * **Continuous Deployment (CD):**

      * **Goal:** To automatically release every change that passes all stages of the pipeline to production.
      * **Process:** Extends Continuous Delivery by automating the final step to production without manual intervention.
      * **Benefit:** Fastest release cycle, but requires very high confidence in automated tests.

#### 2\. Key Components of a CI/CD Pipeline

A typical CI/CD pipeline involves several stages and components:

1.  **Version Control System (VCS):** Git (GitHub, GitLab, Bitbucket) is the foundation. All code changes are committed and pushed here.
2.  **CI/CD Tool (Build Server):** Orchestrates the pipeline (e.g., GitHub Actions, GitLab CI/CD, Jenkins). It monitors the VCS for changes.
3.  **Build Stage:** Compiles code, resolves dependencies, and creates deployable artifacts (e.g., Docker images for our app).
4.  **Test Stage:** Runs various types of automated tests (unit, integration, end-to-end) to validate the changes. (We'll cover testing in detail in a later step, but conceptually it's part of CI).
5.  **Artifact Repository:** Stores the deployable artifacts (e.g., Docker images pushed to AWS ECR, Docker Hub, GCP Container Registry).
6.  **Deployment Stage:** Deploys the artifacts to various environments (development, staging, production). This involves updating servers, orchestrators (ECS, Kubernetes), or serverless functions.

#### 3\. Popular CI/CD Tools

  * **GitHub Actions:** Native to GitHub, YAML-based, highly integrated with repositories. Excellent for open-source and personal projects, and increasingly for enterprises.
  * **GitLab CI/CD:** Native to GitLab, powerful, single-platform solution from source code to deployment.
  * **Jenkins:** Open-source, highly extensible, self-hosted (requires managing servers). Very flexible but more overhead.
  * **CircleCI, Travis CI:** Cloud-based CI/CD services.
  * **Cloud-Native Tools:** AWS CodePipeline/CodeBuild/CodeDeploy, Azure DevOps, Google Cloud Build.

For our example, we'll use **GitHub Actions** due to its widespread adoption and simplicity for integrating with GitHub repositories.

#### 4\. Designing a Simple CI/CD Pipeline for Our Dockerized App (with GitHub Actions)

Let's imagine our project is hosted on GitHub. We'll create a workflow that:

1.  **Triggers** on pushes to the `main` branch.
2.  **Builds** our Docker images (`fastapi-app` and `celery-worker`).
3.  **(Conceptual) Runs Tests:** A placeholder for automated tests.
4.  **Pushes** the images to a container registry (e.g., AWS ECR).
5.  **(Conceptual) Deploys:** Triggers an update on our EC2 instance.

**a. `my_fastapi_app/.github/workflows/ci-cd.yml`:**

Create a `.github/workflows/` directory in your project root, and then create a YAML file (e.g., `ci-cd.yml`) inside it.

```yaml
# my_fastapi_app/.github/workflows/ci-cd.yml

name: FastAPI & Celery CI/CD Pipeline

on:
  push:
    branches:
      - main # Trigger on pushes to the main branch
  pull_request:
    branches:
      - main # Trigger on pull requests targeting the main branch

env:
  # AWS ECR details (replace with your actual AWS details)
  AWS_REGION: eu-west-1 # Your AWS region (e.g., us-east-1, eu-west-1)
  ECR_REPOSITORY_APP: fastapi-app # ECR repository name for FastAPI app
  ECR_REPOSITORY_WORKER: celery-worker # ECR repository name for Celery worker

jobs:
  build_and_push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest # Run on a fresh Ubuntu virtual machine

    # Define permissions required for this job (e.g., to interact with AWS)
    permissions:
      id-token: write # Required for OIDC authentication with AWS
      contents: read # To checkout the repository

    steps:
      - name: Checkout code
        uses: actions/checkout@v4 # Action to checkout your repository code

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} # Stored in GitHub Secrets
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} # Stored in GitHub Secrets
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3 # Required for multi-platform builds, good practice

      - name: Get current commit SHA
        id: commit_sha
        run: echo "SHA_SHORT=$(git rev-parse --short HEAD)" >> $GITHUB_ENV

      - name: Build and Push FastAPI App Image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_APP:latest \
                       -t $ECR_REGISTRY/$ECR_REPOSITORY_APP:${{ env.SHA_SHORT }} \
                       -f Dockerfile.app .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_APP:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_APP:${{ env.SHA_SHORT }}
          echo "APP_IMAGE=$ECR_REGISTRY/$ECR_REPOSITORY_APP:${{ env.SHA_SHORT }}" >> $GITHUB_ENV

      - name: Build and Push Celery Worker Image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_WORKER:latest \
                       -t $ECR_REGISTRY/$ECR_REPOSITORY_WORKER:${{ env.SHA_SHORT }} \
                       -f Dockerfile.worker .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_WORKER:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_WORKER:${{ env.SHA_SHORT }}
          echo "WORKER_IMAGE=$ECR_REGISTRY/$ECR_REPOSITORY_WORKER:${{ env.SHA_SHORT }}" >> $GITHUB_ENV

      - name: Store image tags as outputs (for subsequent jobs)
        id: image_tags
        run: |
          echo "app_image_tag=${{ env.APP_IMAGE }}" >> $GITHUB_OUTPUT
          echo "worker_image_tag=${{ env.WORKER_IMAGE }}" >> $GITHUB_OUTPUT

  # This job depends on 'build_and_push' completing successfully
  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    needs: build_and_push # This job will only run after build_and_push is successful

    # Define permissions required for this job
    permissions:
      id-token: write
      contents: read

    environment: production # Associate with a 'production' environment (for approval flows, etc.)

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # --- SSH into EC2 and pull latest images (Simplistic Deployment) ---
      # WARNING: Direct SSH like this for deployment is very basic and NOT recommended for production.
      # For production, consider AWS CodeDeploy, ECS/EKS deployments, Blue/Green, Canary deployments.
      # This is for illustration of the concept.

      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1.0.3 # Use a community action for SSH
        with:
          host: ${{ secrets.EC2_HOST }} # EC2 Public IP or DNS
          username: ${{ secrets.EC2_USERNAME }} # e.g., 'ubuntu' or 'ec2-user'
          key: ${{ secrets.EC2_SSH_PRIVATE_KEY }} # Private SSH key for EC2
          script: |
            echo "Navigating to app directory..."
            cd /home/${{ secrets.EC2_USERNAME }}/my_fastapi_app # Adjust path if needed

            echo "Setting environment variables..."
            # Pull secrets from a secure store like AWS Systems Manager Parameter Store
            # Example (if you used Parameter Store):
            # export DATABASE_URL=$(aws ssm get-parameter --name "/myapp/prod/DATABASE_URL" --with-decryption --query "Parameter.Value" --output text --region ${{ env.AWS_REGION }})
            # ... set other env vars similarly ...
            # Or read from a .env file you manage on the EC2 instance

            # Update docker-compose.yml to use the new image tags
            # Replace 'latest' with the specific SHA tag from the build_and_push job
            # This is tricky; a better way is to use envsubst or a deployment script that updates the compose file.
            # For this simple example, we'll assume 'latest' is updated and pulled.

            echo "Pulling latest Docker images..."
            docker compose pull app worker

            echo "Bringing up containers with new images..."
            docker compose up -d app worker --no-build # --no-build ensures it uses existing images

            echo "Cleaning up old images..."
            docker system prune -f # DANGER: This removes ALL unused images! Be careful in prod.
            # A safer approach is to specifically remove old versions of *your* images.

            echo "Deployment complete!"

      # --- Placeholder for Test Stage (to be implemented in Step 6) ---
      # You could add another job here (e.g., 'test_api') that runs after build_and_push
      # and before deploy, ensuring tests pass before deployment.
      # This job would also run on 'ubuntu-latest', check out code, and then run `pytest`.
      # test:
      #   name: Run Automated Tests
      #   runs-on: ubuntu-latest
      #   needs: build_and_push
      #   steps:
      #     - name: Checkout code
      #       uses: actions/checkout@v4
      #     - name: Set up Python
      #       uses: actions/setup-python@v5
      #       with:
      #         python-version: '3.11'
      #     - name: Install dependencies
      #       run: pip install -r requirements.txt
      #     - name: Run pytest
      #       run: pytest # Your actual test command
```

**b. Environment Variables & Secrets in CI/CD:**

You **MUST NOT** hardcode sensitive information (AWS keys, SSH private keys, database passwords) directly in your `ci-cd.yml` file.

  * **GitHub Secrets:** GitHub Actions provides a secure way to store sensitive environment variables.
    1.  Go to your GitHub repository.
    2.  Click **Settings** -\> **Secrets and variables** -\> **Actions**.
    3.  Click **New repository secret**.
    4.  Add the following secrets (make sure to use your actual values):
          * `AWS_ACCESS_KEY_ID` (Your AWS Access Key ID)
          * `AWS_SECRET_ACCESS_KEY` (Your AWS Secret Access Key)
          * `EC2_HOST` (The public IP or DNS of your EC2 instance)
          * `EC2_USERNAME` (The SSH username for your EC2, e.g., `ubuntu` or `ec2-user`)
          * `EC2_SSH_PRIVATE_KEY` (The entire content of your EC2 private key file, including `-----BEGIN RSA PRIVATE KEY-----` and `-----END RSA PRIVATE KEY-----`)

#### 5\. Important Considerations for Production CI/CD

  * **Security:** Never expose secrets directly. Use secure secret management tools.
  * **Rollbacks:** Have a strategy for quickly rolling back to a previous working version if a deployment fails or introduces critical bugs.
  * **Deployment Strategies:**
      * **Blue/Green Deployment:** Run two identical environments (Blue is current, Green is new). Route traffic to Green after testing. Quick rollback by routing back to Blue.
      * **Canary Deployment:** Roll out new features to a small subset of users first. If stable, gradually increase rollout.
      * **Rolling Updates:** Gradually replace old instances with new ones (often built-in with orchestrators like ECS/Kubernetes).
  * **Testing:** Comprehensive automated tests (unit, integration, end-to-end) are crucial for confidence in automated deployments.
  * **Database Migrations:** Manage database schema changes carefully within your CI/CD pipeline (e.g., run Alembic migrations *before* deploying new app code).
  * **Monitoring & Alerting Integration:** Ensure your deployment pipeline updates monitoring dashboards and that alerts are active during and after deployment.

-----

#### Your Turn to Practice:

1.  **Set up GitHub Repository:** If your project isn't already on GitHub, create a new repository and push your `my_fastapi_app` code to it.
2.  **Add `Dockerfile.app` and `Dockerfile.worker`:** Ensure these are in your project root as discussed in the previous step.
3.  **Create `.github/workflows/ci-cd.yml`:** Copy the provided YAML content into this file.
4.  **Configure GitHub Secrets:** Go to your GitHub repository settings and add the necessary secrets (`AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `EC2_HOST`, `EC2_USERNAME`, `EC2_SSH_PRIVATE_KEY`).
5.  **Commit and Push:** Push your changes to the `main` branch of your GitHub repository.
6.  **Observe Workflow Execution:** Go to the "Actions" tab in your GitHub repository. You should see your "FastAPI & Celery CI/CD Pipeline" running. Observe the logs for each step (Checkout, Configure AWS, Login ECR, Build & Push, Deploy).

<!-- end list -->

  * **Important:** The `deploy` step's SSH action assumes your EC2 instance is reachable and correctly configured for SSH with the provided key. For a real deployment, you'd refine this significantly.

This exercise gives you hands-on experience with automating your build and push process, which is the cornerstone of CI/CD.

When you're ready, we'll dive into **Phase 4, Step 5: Caching Strategies**, which focuses on improving your API's performance.