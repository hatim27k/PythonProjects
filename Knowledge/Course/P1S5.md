Alright, let's delve into **Phase 1, Step 5: Object-Oriented Programming (OOP) in Python**.

With your C++ and Java background, you'll find the core concepts of OOP very familiar. Python's approach is often described as "batteries included" and more dynamic, emphasizing convention over strict enforcement for things like access modifiers.

-----

### Phase 1, Step 5: Object-Oriented Programming (OOP) in Python

#### 1\. Defining Classes and Objects

**Python:**

  * Classes are blueprints for creating objects. Defined using the `class` keyword.
  * Class names typically follow `CamelCase` convention (PEP 8).
  * Objects are instances of classes.

**C++ / Java Comparison:**

  * Very similar to class definitions in C++ and Java.
  * No semicolons after class definitions or within them.

**Examples:**

```python
# Basic Class Definition
class Dog:
    # Class attribute (shared by all instances of the class)
    species = "Canis familiaris"

    # Constructor method (initializer)
    # 'self' refers to the instance of the class (like 'this' in Java/C++)
    def __init__(self, name, age):
        # Instance attributes (unique to each object)
        self.name = name
        self.age = age

    # Instance method
    def bark(self):
        return f"{self.name} says Woof!"

    def get_info(self):
        return f"{self.name} is a {self.age}-year-old {self.species}."

# Creating Objects (Instances of the Class)
my_dog = Dog("Buddy", 3)
your_dog = Dog("Lucy", 5)

# Accessing attributes
print(f"My dog's name: {my_dog.name}")
print(f"Your dog's age: {your_dog.age}")
print(f"Dog species (class attribute): {Dog.species}") # Access via class name
print(f"My dog's species (instance access): {my_dog.species}") # Can also be accessed via instance

# Calling methods
print(my_dog.bark())
print(your_dog.get_info())

# Class attributes can be accessed and modified via the class itself
Dog.species = "Domestic Dog"
print(f"New species (class access): {Dog.species}")
print(f"New species (instance access for my_dog): {my_dog.species}")
```

-----

#### 2\. The `self` Parameter

  * Every instance method (a function defined within a class) must have `self` as its first parameter.
  * `self` is a convention (you *could* name it something else, but *never* do it).
  * When you call `my_dog.bark()`, Python automatically passes `my_dog` as the `self` argument to the `bark` method.
  * It's Python's way of implicitly passing the instance itself, similar to how `this` works in Java/C++.

-----

#### 3\. "Dunder" Methods (Special Methods / Magic Methods)

  * Methods surrounded by double underscores (e.g., `__init__`, `__str__`, `__repr__`) are special methods.
  * They allow you to define how objects behave in certain situations (e.g., initialization, string representation, arithmetic operations, iteration, etc.).
  * These are similar to operator overloading in C++ or overriding `toString()` in Java.

##### `__init__(self, ...)`: The Constructor

  * As seen above, this method is called automatically when a new object is created.
  * It's used to initialize the instance's attributes.

##### `__str__(self)`: String Representation (for users)

  * Called by `str()`, `print()`, and `f-strings`.
  * Should return a human-readable string representation of the object.

##### `__repr__(self)`: String Representation (for developers)

  * Called by `repr()` and when the object is displayed in an interactive interpreter (if `__str__` is not defined).
  * Should return an "official" string representation that, if possible, could be used to recreate the object (or at least provide unambiguous debugging info).

**Examples:**

```python
class Book:
    def __init__(self, title, author, pages):
        self.title = title
        self.author = author
        self.pages = pages

    def __str__(self):
        # Human-readable representation
        return f'"{self.title}" by {self.author}, {self.pages} pages'

    def __repr__(self):
        # Unambiguous representation, ideally recreatable
        return f'Book(title="{self.title}", author="{self.author}", pages={self.pages})'

    def __len__(self):
        # Another dunder method: allows len(book_obj)
        return self.pages

my_book = Book("The Hitchhiker's Guide to the Galaxy", "Douglas Adams", 193)

print(my_book)        # Calls __str__
print(str(my_book))   # Explicitly calls __str__
print(repr(my_book))  # Explicitly calls __repr__
print(f"Length of book (pages): {len(my_book)}") # Calls __len__
```

-----

#### 4\. Inheritance

**Python:**

  * Supports single and multiple inheritance.
  * Class `ChildClass(ParentClass)` inherits from `ParentClass`.
  * Method overriding works as expected.
  * `super()` is used to call methods of the parent class (especially useful in `__init__` and overridden methods).

**C++ / Java Comparison:**

  * Similar to `extends` in Java or public inheritance in C++.
  * Python's multiple inheritance is similar to C++'s, but with a different Method Resolution Order (MRO) handled automatically. Java does not support multiple inheritance of classes (only interfaces).

**Examples:**

```python
# Parent Class
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        raise NotImplementedError("Subclass must implement abstract method") # Concept of abstract method

# Child Class inheriting from Animal
class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name) # Call parent's __init__ method
        self.breed = breed

    def speak(self): # Method overriding
        return f"{self.name} the {self.breed} says Woof!"

    def fetch(self, item):
        return f"{self.name} fetches the {item}."

# Another Child Class
class Cat(Animal):
    def __init__(self, name):
        super().__init__(name)

    def speak(self): # Method overriding
        return f"{self.name} says Meow!"

my_dog = Dog("Rex", "German Shepherd")
my_cat = Cat("Whiskers")

print(my_dog.speak())
print(my_dog.fetch("ball"))
print(my_cat.speak())

# isinstance() and issubclass()
print(f"Is my_dog an instance of Dog? {isinstance(my_dog, Dog)}")
print(f"Is my_dog an instance of Animal? {isinstance(my_dog, Animal)}")
print(f"Is Dog a subclass of Animal? {issubclass(Dog, Animal)}")
```

-----

#### 5\. Access Modifiers (Public, Protected, Private)

**Python:**

  * Python does not have strict `public`, `private`, or `protected` keywords like Java or C++.

  * It relies on **convention** and **name mangling** for "private" attributes.

  * **Public (default):** All attributes and methods are public by default. You can access them directly from outside the class.

      * `self.attribute_name`
      * `def public_method(self):`

  * **Protected (convention):** Start the name with a single underscore `_`. This is a convention indicating that the attribute/method is intended for internal use within the class or its subclasses, but it's *not enforced*.

      * `self._protected_attribute`
      * `def _protected_method(self):`

  * **Private (name mangling):** Start the name with a double underscore `__` (and *not* ending with `__`). This triggers "name mangling," where Python internally renames the attribute to `_ClassName__attribute_name`. While it makes it harder to access from outside, it's *not truly private* and can still be accessed if you know the mangled name. It primarily helps prevent naming collisions in inheritance.

      * `self.__private_attribute`
      * `def __private_method(self):`

**C++ / Java Comparison:**

  * C++ uses `public:`, `protected:`, `private:`.
  * Java uses `public`, `protected`, `private` keywords.
  * Python's approach is much more flexible, prioritizing "we are all consenting adults here" over strict access control.

**Examples:**

```python
class MyClass:
    def __init__(self):
        self.public_var = "I am public"
        self._protected_var = "I am protected (by convention)"
        self.__private_var = "I am private (name mangled)"

    def public_method(self):
        print(f"Inside public_method: {self.public_var}")
        self._protected_method()
        self.__private_method()

    def _protected_method(self):
        print(f"Inside protected_method: {self._protected_var}")

    def __private_method(self):
        print(f"Inside private_method: {self.__private_var}")

obj = MyClass()

# Accessing public members (normal)
print(obj.public_var)
obj.public_method()

# Accessing protected members (possible, but discouraged)
print(obj._protected_var)
obj._protected_method()

# Attempting to access private members directly (will fail)
# print(obj.__private_var) # AttributeError: 'MyClass' object has no attribute '__private_var'
# obj.__private_method()   # AttributeError: 'MyClass' object has no attribute '__private_method'

# Accessing mangled private member (if you know the mangled name)
print(obj._MyClass__private_var) # Possible, but breaks encapsulation
obj._MyClass__private_method()   # Possible, but breaks encapsulation
```

-----

#### 6\. Properties (`@property` decorator)

**Python:**

  * The `@property` decorator allows you to define methods that can be accessed like attributes.
  * It's the "Pythonic" way to implement getters, setters, and deleters, providing controlled access to attributes without exposing raw data or requiring explicit `get`/`set` prefixes (like `getName()` / `setName()` in Java).

**C++ / Java Comparison:**

  * Similar to Java's getter/setter methods, but accessed like fields.
  * In C++, you might overload `operator=` or define custom accessors.

**Examples:**

```python
class Circle:
    def __init__(self, radius):
        self._radius = radius # Store the actual value in a "protected" variable

    @property # Getter method
    def radius(self):
        """The radius of the circle."""
        print("Getting radius...")
        return self._radius

    @radius.setter # Setter method
    def radius(self, value):
        print("Setting radius...")
        if not isinstance(value, (int, float)):
            raise TypeError("Radius must be a number.")
        if value < 0:
            raise ValueError("Radius cannot be negative.")
        self._radius = value

    @radius.deleter # Deleter method
    def radius(self):
        print("Deleting radius...")
        del self._radius

    @property # Read-only property (no setter or deleter defined)
    def diameter(self):
        return self._radius * 2

c = Circle(5)

# Accessing like an attribute (calls the getter)
print(f"Initial radius: {c.radius}")
print(f"Diameter: {c.diameter}")

# Setting like an attribute (calls the setter)
c.radius = 10
print(f"New radius: {c.radius}")

# This will raise a ValueError from the setter
# c.radius = -2

# This will raise a TypeError from the setter
# c.radius = "abc"

# Deleting the property (calls the deleter)
del c.radius
# print(c.radius) # AttributeError: '_Circle' object has no attribute '_radius'
```

-----

#### Your Turn to Practice:

1.  **Employee Class (`employee.py`):**

      * Create a `class Employee`.
      * In its `__init__` method, take `name`, `employee_id`, and `salary`.
      * Add a class attribute `company_name` (e.g., "Tech Solutions Inc.").
      * Implement an instance method `get_annual_salary()` that returns `salary * 12`.
      * Implement a `__str__` method to return a human-readable string like "Employee: [Name] ([ID]), Salary: $[Salary]".
      * Create a few `Employee` objects and test their attributes and methods.

2.  **Manager Class (Inheritance) (`manager.py`):**

      * Create a `class Manager` that inherits from `Employee`.
      * The `Manager` constructor should also take `name`, `employee_id`, `salary`, and additionally `department`.
      * Override the `get_annual_salary()` method for `Manager` to include a bonus of 10% on top of the base salary.
      * Add a new method `assign_project(project_name)` specific to `Manager`.
      * Create a `Manager` object and test its inherited and new methods.

3.  **Bank Account (Properties) (`bank_account.py`):**

      * Create a `class BankAccount`.
      * In `__init__`, initialize a `_balance` (using underscore to denote it's an internal variable, implying a property will control access).
      * Implement a `@property` for `balance`:
          * The getter should return the current `_balance`.
          * The setter should ensure that any new value for `balance` is non-negative. If a negative value is attempted, raise a `ValueError`.
      * Add `deposit(amount)` and `withdraw(amount)` methods. These methods should directly interact with `_balance` but ensure amounts are positive and withdrawals don't exceed the balance.
      * Create a `BankAccount` object and test its `balance` property and methods. Try to set a negative balance directly via the property to confirm the `ValueError`.

These exercises will give you a solid grip on Python's OOP features. Once you're done, let me know, and we'll proceed to **Error Handling**.